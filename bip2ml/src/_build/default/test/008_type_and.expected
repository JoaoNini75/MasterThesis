type number =
  | Neg of int
  | Pos of int * bool * int
  | Zero

type simple = number * bool

and complex =
  | Num1 of simple * int
  | Num2 of simple * bool

and third = complex * simple

let test_construction (num) : simple =
  let x = Pos (num, true, 3) in
  let y = (x, (true || false)) in
  y
(*@ ensures true *)

let match_destruct () : int =
  let x = Zero in
  match x with
  | Zero -> 0
  | Neg (n) -> n
  | Pos (n, b, third) -> 
    if b
    then begin 
      third
    end else begin 
      (n + 1)
    end;
(*@ ensures true *)

type number2 =
  | Pos2 of int * int
  | Neg2
  | Zero2

let match_assert (x : int) =
  let y = 
    if (x > 0)
    then begin 
      Pos2 (2, 4)
    end else begin 
      Zero2
    end
  in
  let res = (
    match y with
    | Pos2 (i, n) -> 10
    | Neg2 -> -10
    | Zero2 -> 0
  ) in
  assert ((res >= -10));
  res
(*@ ensures x > 0 -> result = 10
    ensures x = 0 -> result = 0
    ensures x < 0 -> result = -10 *)

let test () =
  Neg2
(*@ ensures true *)

type number3 =
  | Pos3 of int
  | Neg3 of int
  | Zero3

let array_type_param (x_l : int) (x_r : int) (n : int array) (l : number3 array) (k : int) (a_l : int array) (a_r : int array) (b_l) (b_r) : int array =
  let i_l = ref (0) in
  let i_r = ref (0) in
  i_l := (!i_l + 30);
  i_r := (!i_r + 30);
  [| 1; 2; k |]
(*@	ensures true *)


