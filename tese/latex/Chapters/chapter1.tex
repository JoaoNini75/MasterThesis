%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter1.tex
%% NOVA thesis document file
%%
%% Chapter with introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter1.tex}%

\chapter{Introduction}
\label{cha:introduction}

\section{Motivation} 

The impact of errors in programs can vary greatly.
Sometimes it can make you lose a match of a game you play to relax after a long, stressful day.
But sometimes it can make commercial airplanes with hundreds of people catastrophically crash~\cite{air-india}.
Additionally, there are other situations as dangerous as a plane crash: medical equipment failure~\cite{therac-25}, space accidents~\cite{ariane}, defense systems errors~\cite{patriot}... the list is not short.
Clearly, the approach to ensure the correctness of some software has to be extremely thorough and methodical.

Deductive verification has proven to be the most accurate way to prove that a certain program outputs what is intended given its inputs, assuming the execution of that program finishes.
Although this is the most effective way, it is also the one that requires the most investment: professionals that can write the specifications for the programs and then help theorem solver discard verification conditions.
As the reader can imagine, most companies prefer to resort to the cheaper, faster methods of testing.
Therefore, there has to be a simpler way of proving, still using deductive verification, that a program is correct.
One of the most promising paths is \textbf{program equivalence}, a crucial subject within the field of formal verification~\cite{DBLP:journals/fmsd/Strichman18}.


\section{Problem Definition}

The question that this work focus its attention on is:

\begin{quote}
    \centering
   %\emph{Can we automatically prove that two programs P$_1$ and P$_2$ are correct and equivalent?}
    \emph{Can we automatically prove that two different programs are correct and equivalent?}
\end{quote}

Despite looking like a simple question, there is no simple answer.
This is an issue that people have tried to address for decades, yet we did not find a definitive solution.
There are several schools of software verification~\cite{DBLP:conf/fm/BrainP24} but, as expected, all of them have advantages and disadvantages.
However, we believe that human-assisted is the way, since it leaves many less bugs behind, compared to under-approximate methods and, at the same time, does not alert the programmer to errors that are not actually errors.
Of course that this carries an extra human effort, in developing the specification for the programs and sometimes in discharging verification conditions.
So, when we mean automatic proof of equivalence, we mean no human interaction after writing the specification, although automatic inference of loop invariants and variants would definitely make the programmer's life much simpler.

In the context of human-assisted verification, and considering two versions of the same program, we first need to prove that the simpler program (in terms of specification) is correct, using already existent methods.
Then, to prove that the more complex one is also correct, we establish a connection between the two.
This approach may enable an easier and faster proof that programs are correct, constrating with the more common way of proving that the two are correct independently of each other. 
WhyRel~\cite{whyrel} is an auto-active tool that aims to verify relational properties of pointer programs through relational region logic.


\section{Goals and Contributions}

This work aims to bring to OCaml~\cite{ocaml} the concept of \emph{biprograms}, facilitating the task of proving that two different programs are equivalent.
Those programs are not expected to have identical structures, but since there is the need to reason about them jointly, there are still some restrictions explained later.
To achieve this, our tool will steer towards the direction of the translation rules defined in WhyRel.
The work on product programs~\cite{DBLP:conf/fm/BartheCK11} presents a good set of rules, but WhyRel's are more refined and easier to apply in practice.
It is also important to mention that, in order to verify the generated program, we will use GOSPEL~\cite{DBLP:conf/fm/ChargueraudFLP19} to write the specification and Cameleer~\cite{DBLP:conf/cav/PereiraR20}, so that the user can utilize Why3~\cite{why3} to finish the proof.

Since our tool is a transpiler and we aim to output OCaml code, we still need to clarify what will the input be like.
The ideal source language would be one whose syntax is as close as possible to OCaml's, so that programmers used to the target language do not have a steep learning curve if they need to prove equivalence of their programs. 
WhyRel's biprograms language is a good starting point, since it guides us on what a language capable of reasoning about relational properties needs to feature.
However, it has many differences to OCaml in relation to syntax.
Therefore, we propose to define a new language that has enough features so that one can write functional code as done in OCaml, while disposing of mechanisms to reason about two programs in tandem.

Besides program equivalence, we explore if our tool can reason about other relational properties, such as program inequivalence or equivalence between corresponding memory segments (after the execution of the programs finish).
To conduct a more in-depth examination, we also observe how different it is, in practice, to prove different relational properties.
i.e., what does the user need to change in the specification or code in order to prove equivalence versus inequivalence for example.


\section{Thesis Structure}

\begin{itemize}
    \setlength\itemsep{0.1em}
    \item Chapter \hyperref[cha:background]{2} presents the foundational concetps and tools underlying the scientific subject of this work.

    \item In chapter \hyperref[cha:state_of_the_art]{3}, we explain the most relevant developments regarding the subject of program equivalence proof: self-composition, cross-products, product programs and WhyRel.
    The most relevant ones for this thesis are the last two.

    \item Chapter \hyperref[cha:methodology]{4} starts by describing the way we based our tool on WhyRel's translation rules.
    After that, we present the architecture of bip2ml and how it is integrated in the Cameleer pipeline.
    Next, we describe our biprograms language, BipLang, and discuss some implementations details.
    Finally, we demonstrate the application of the translation rules by our transpiler.

    \item In chapter \hyperref[cha:case_studies]{5}, we showcase several examples of what our transpiler is capable of. 
    We start with a simple program, its translation and proof.
    Then, we do the same but for real world examples that demonstrate the usefulness of bip2ml.
    
    \item Finally, chapter \hyperref[cha:conclusion]{6} summarizes our contributions, the limitations of our tool and possible future work.
\end{itemize}




\iffalse
\section{Program Equivalence}
\label{sec:program_equivalence}

Program equivalence stands out as a crucial subject within the field of formal verification~\cite{DBLP:journals/fmsd/Strichman18}.
"Traditional" program correctness by itself is usually harder to prove than program equivalence, especially when it comes to real world programs, making the latter a topic whose research can reach success easier.

This~\cite{DBLP:journals/fmsd/KlebanovRU18} work brings to light an interesting approach called regression verification, which combines regression testing with formal verification.
It is based on invariant inference techniques to automatically prove that two imperative pointer programs are equivalent, in the context of one being an updated version of the other.
By updated version we mean that the program has now more features, has been refactored or went through performance optimizations.

This automatic proof method is achieved by first transforming the two programs into Horn clauses over uninterpreted predicate symbols. 
Then, these clauses constrain equivalence witnessing coupling predicates that establish the relation of the two programs at key points.
Finally, if there is a solution for the coupling predicates, a Horn constraint solver is utilized to find it.
It may be important to mention that, according to the authors, the approach was implemented and its effectiveness demonstrated.

Besides the fact that the focus of our work does not include pointer programs, it is important to note that, due to the lack of human-written specification, this approach has its limitations.
The range of situations where regression verification can be applied is still confined to some programming language constructs and there are issues regarding the scalability.
\fi
