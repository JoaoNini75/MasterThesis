%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter1.tex
%% NOVA thesis document file
%%
%% Chapter with introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter1.tex}%

\chapter{Introduction}
\label{cha:introduction}

\section{Motivation} 

The impact of errors in programs can vary greatly.
Sometimes it can make you lose a match of a game you play to relax after a long, stressful day.
But sometimes it can make commercial airplanes with hundreds of people catastrophically crash.
However, there are other situations as dangerous as a plane crash: medical equipment failure, nuclear accidents, defense systems errors... the list is not short.
Clearly, the approach to ensure the correctness of some software has to be extremely thorough and methodical.

Deductive verification has proven to be the most accurate way to prove that a certain program outputs what is intended given its inputs.
Although this is the most effective way, it is also the one that requires the most investment: professionals that can write the specifications for the programs and then help theorem solver discard verification conditions.
As the reader can imagine, most companies prefer to resort to the cheaper, faster methods of testing.
Therefore, there has to be a simpler way of proving, still using deductive verification, that a program is correct.
That way is program equivalence and product programs.


\section{Problem Definition}

The question that this work focus its attention on is:

\begin{quote}
    \centering
    \emph{Can we automatically prove that two programs P$_1$ and P$_2$ are correct and equivalent?}
\end{quote}

Despite looking like a simple question, there is no simple answer.
This is an issue that people have tried to address for decades, yet we did not find a definitive solution.
There are several schools of software verification~\cite{DBLP:conf/fm/BrainP24} but, as expected, all of them have advantages and disadvantages.
However, we believe that human-assisted is the way, since it leaves many less bugs behind, compared to under-approximate methods and, at the same time, does not alert the programmer to errors that are not actually errors.
Of course that this carries an extra human effort, in developing the specification for the programs and sometimes in discharging verification conditions.

In the context of human-assisted verification and programs P$_1$ and P$_2$, we need to first prove that the simpler program is correct, using already existent methods and then establish a connection between them to prove that the more complex is also correct.
Product programs appear as a promising solution that came to light from the combination of two other methods called self-composition and cross-products.
This solution takes the best of both worlds in order to overcome their limitations, which will be explained later, in chapter \hyperref[cha:state_of_the_art]{3}.
Our work will, therefore, adapt product programs to be applied in the OCaml programming language, which could then be verified using Cameleer.


\section{Goals and Contributions}

TODOOO
This work aims to bring to OCaml the concept of \emph{product programs}, facilitating the task of proving that two different programs are behaviorally equivalent.
This is especially relevant in cases where proving a simpler program and the relation between that and a more complex version is more peaceful than proving the correctness of both versions separately.


\section{Thesis Structure}

\begin{itemize}
    \setlength\itemsep{0.1em}
    \item Chapter \hyperref[cha:background]{2} contains a series of concepts, like relational Hoare logic, and tools, such as Cameleer, that are essential to understand the foundations of our work.

    \item In chapter \hyperref[cha:state_of_the_art]{3}, we will enumerate and explain the most relevant developments regarding the subject of program equivalence proof.

    \item Chapter \hyperref[cha:methodology]{4} describes the theory that supports our work and explains the details of the implementation of our tool.

    \item In chapter \hyperref[cha:case_studies]{5}, we showcase several examples of what our transpiler is capable of. 
    We will start with simple programs and increment progressively until we finaly demonstrate the usefulness with real world examples.
    
    \item Finally, chapter \hyperref[cha:conclusion]{6} summarizes our contributions, the limitations of our tool and possible future work.

\end{itemize}




\iffalse
\section{Program Equivalence}
\label{sec:program_equivalence}

Program equivalence stands out as a crucial subject within the field of formal verification~\cite{DBLP:journals/fmsd/Strichman18}.
"Traditional" program correctness by itself is usually harder to prove than program equivalence, especially when it comes to real world programs, making the latter a topic whose research can reach success easier.

This~\cite{DBLP:journals/fmsd/KlebanovRU18} work brings to light an interesting approach called regression verification, which combines regression testing with formal verification.
It is based on invariant inference techniques to automatically prove that two imperative pointer programs are equivalent, in the context of one being an updated version of the other.
By updated version we mean that the program has now more features, has been refactored or went through performance optimizations.

This automatic proof method is achieved by first transforming the two programs into Horn clauses over uninterpreted predicate symbols. 
Then, these clauses constrain equivalence witnessing coupling predicates that establish the relation of the two programs at key points.
Finally, if there is a solution for the coupling predicates, a Horn constraint solver is utilized to find it.
It may be important to mention that, according to the authors, the approach was implemented and its effectiveness demonstrated.

Besides the fact that the focus of our work does not include pointer programs, it is important to note that, due to the lack of human-written specification, this approach has its limitations.
The range of situations where regression verification can be applied is still confined to some programming language constructs and there are issues regarding the scalability.
\fi
