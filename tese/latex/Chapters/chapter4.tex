%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Methodology}
\label{cha:methodology}


\FloatBarrier
\section{From WhyRel to bip2ml}
\label{sec:whyrel_to_bip2ml}

WhyRel describes a pratical approach to the verification of program equivalence based on product programs.
It also provides a set of \hyperref[fig:translation-biprograms-rules]{rules} that guides the translation, in the case of WhyRel, from the biprograms language to WhyML.
Its authors deeply explore the problems that pointer based programs bring to the table, but this is not an objetive of this thesis.
Instead, we defined and formalized a programming language called $BipLang$.
BipLang's main purpose is writing biprograms and was based on the biprograms language used in WhyRel's work.
BipLang was designed to accept Gospel annotations and to be as similar as possible to OCaml in terms of syntax and semantics.
We did that in order to allow programmers that are used to that language to verify the equivalence of their programs without needing to learn a new language or completely rewrite their code or specification.
Then, we translate/transpile the biprograms using the rules defined by WhyRel's authors to produce Gospel-annotated OCaml code.


\FloatBarrier
\section{bip2ml}
\label{sec:bip2ml}

\FloatBarrier
\subsection{Overview and architecture}
\label{subsec:bip2ml_overview}

$bip2ml$ is a transpiler that takes Gospel-annotated BipLang code and outputs Gospel-annotated OCaml code.
This tool brings the contributions of WhyRel into the world of OCaml, Gospel and Cameleer.

We now describe bip2ml's pipeline and how it \hyperref[fig:bip2ml_cameleer_pipeline]{integrates} with Cameleer.
The users are expected to start with two programs and aim to formally verify that they are equivalent.
The first step requires the user to provide the alignment of the two unary programs, writing a BipLang program with the necessary Gospel annotations.
After that, the user feeds bip2ml that .bip file to bip2ml and the transpiler starts its work to output the OCaml + Gospel program.
That file can then be fed to Cameleer, which in turn will take care of the rest of the verification process, exactly as if we gave it an OCaml program that we wrote manually.

\begin{figure}[htbp]
  \centering
  \includegraphics[max width=\textwidth]{bip2ml+cameleer_pipeline}
  \caption{Architecture and verification pipeline of bip2ml and Cameleer.}
  \label{fig:bip2ml_cameleer_pipeline}
\end{figure}

The bip2ml transpiler is itself also a \hyperref[fig:bip2ml_cameleer_pipeline]{pipeline}, that takes the input through four phases / components before terminating.
The first component is the lexer, which defines what are the keywords and tokens accepted by BipLang; if any error occurs during this phase, bip2ml outputs \emph{"lexical error"} to the terminal.
We used ocamllex~\cite{ocamllex} to develop our lexer.
Representing the second part of the transpiler, we have the parser, that takes the lexer's output and, by comparing it with the rules we define that are valid BipLang constructions, determines if the source code's structure is valid or not.
If it is not, it outputs \emph{"syntax error"} to the terminal.
To program the parser, we utilized Menhir~\cite{menhir}.
The output of the parser is an AST, the BipLang AST, which is the input of the next phase: the translator.
This component is the one responsible for translating the BipLang AST into the OCaml AST, according to the 8 rules defined by WhyRel; this phase does not fail.
Finally, we named the last part of our transpiler the printer, since its function is to receive the OCaml AST from the translator and outputting to the terminal or to a file the final OCaml code with all the Gospel specifications.
Both the translator and the printer were implemented using OCaml directly.

\begin{figure}[htbp]
  \centering
  \includegraphics[max width=\textwidth]{bip2ml_pipeline}
  \caption{Architecture and pipeline of bip2ml.}
  \label{fig:bip2ml_pipeline}
\end{figure}

We also developed a VSCode extension that provides syntax highlighting for BipLang.
Although it is dispensable, it certainly was extremely helpful during the whole development and testing of bip2ml, and it may also be a relevant aid to anyone that programs in BipLang.
It was heavily based on OCaml Labs' VSCode OCaml Platform~\cite{ocaml-platform}, since the syntax of OCaml and BipLang are nearly identical.


\FloatBarrier
\subsection{BipLang: language definition}
\label{subsec:lang_def}

BipLang's syntax, semantics and AST are very similar to OCaml's.
Although BipLang implements the most common OCaml language constructions, there are definitely some missing, such as exceptions and object-oriented features.
Taking that into consideration, it is also important to remember that, regarding the scope of this thesis, these constructions can not be seen as having a high priority or relevance.
On the other hand, our language adds 3 constructions that are not present in OCaml: the pipe, the floors and the conditionally aligned loops.
Their semantics are the same as in WhyRel's work.

We now present the grammar of our language, BipLang.
The syntaxes of the most relevant rules are given by the following extended BNF definition.
Note that Biplang's keywords are written in orange.

\begin{lstlisting}[mathescape, basicstyle=\ttfamily, columns=flexible,
                    emph={type, and, let, rec, if, then, else, mod, in, for, while, do, done, to, begin, end, assert, match, with, of, open, include,ref},
                    emphstyle=\ttfamily\bfseries\color{myorange}]
file ::= decl*

decl ::= 
            | def
            | spec
            | typedef

spec ::= { loc: location; text: string; }

typedef ::=
              | type id = payload (and typedef)?
              | type id = $\overrightarrow{constructor}$ (and typedef)?

payload ::= 
              | $\overrightarrow{bt}$
              | $\overrightarrow{id}$

constructor ::= idc * payload?

def ::= let rec? id ($\overrightarrow{parameter}$) : fun_ret? = $\overrightarrow{expr}$ spec

expr ::=
            | ()
            | (e)
            | c
            | id
            | -e
            | $\neg$ e
            | ref e 
            | !e
            | e + e
            | e - e
            | e * e
            | e / e
            | e mod e
            | e = e
            | e <> e
            | e < e
            | e $\leq$ e
            | e > e
            | e $\geq$ e
            | e == e
            | e != e
            | e && e
            | e || e 
            | let id = e in $\overrightarrow{e}$
            | if e then e else e
            | for id = e to e do spec? e done 
            | while e do spec? e done 
            | id := e
            | assert (e)
            | match id with ($\overrightarrow{case}$)
            | ($\overrightarrow{e}$)
            | idc ($\overrightarrow{e}$)
            | fun_id ($\overrightarrow{e}$)
            | Module_id.fun_id ($\overrightarrow{e}$)
            | def in e
            
            $\emph{arrays}$
            | [| $\overrightarrow{e}$ |]
            | id.(e)
            | id.(e) <- e

            $\emph{lists}$
            | [ $\overrightarrow{e}$ ]
            | e :: [ $\overrightarrow{e}$ ]
            | e @ [ $\overrightarrow{e}$ ]

            $\emph{introduced by BipLang}$
            | e <|> e $\emph{(pipe)}$
            | $\lfloor e \rfloor$ $\emph{(floors)}$
            | while e <|> e . e <|> e do spec? e done
            $\emph{(conditionally aligned loops)}$

c ::=
        | None
        | int
        | bool
        | string

\end{lstlisting}

We simplified some things for the sake of readibility and there are some omissions in the grammar, which we will explain now.
Firstly, we use $c$ to simply represent a constant.
Additionally, notice that we use $id$ and $idc$.
They both refer to identifiers but $id$ refers to an all lowercase identifier, while $idc$ stands for "capitalized id", so its first letter is capital.
This is important to distinguish since module calls and type constructors, for example, use capitalized names, but lowercase identifiers are the standard for the names of variables and functions, among others.
Next, we have to show the difference between $bt$ (bip type) and $at$ (any type).
$bt$ represents the basic types (bool, int, string, none), but $at$ extends that definition to also allow $id$.
This is useful, for example, when we have a parameter of a user-defined type:

\begin{lstlisting}[mathescape, basicstyle=\ttfamily, columns=flexible,
                    emph={type, and, let, rec, if, then, else, mod, in, for, while, do, done, to, begin, end, assert, match, with, of, open, include,ref},
                    emphstyle=\ttfamily\bfseries\color{myorange}]
type advanced_number = 
	| Pos of int
	| Neg of int
	| Zero

let example (an : advanced_number) : advanced_number = begin
	(...)
end
\end{lstlisting}

Otherwise, we would be limited to parameters and function returns of the basic types ($bt$).
$parameter$ is pretty straightforward: it represents a parameter, with all its possible variations, having pipe, floors or none, explicitly saying its type or not.
$fun\_ret$ is optional and represents what the function returns, allowing explicit or implicit type definition and also pipe, floors or none of them.
$constructor$ represents the definition of a constructor within a type defintion and $payload$ represents a type definition that has no constructors:

\begin{lstlisting}[mathescape, basicstyle=\ttfamily, columns=flexible,
                    emph={type, and, let, rec, if, then, else, mod, in, for, while, do, done, to, begin, end, assert, match, with, of, open, include,ref},
                    emphstyle=\ttfamily\bfseries\color{myorange}]
type constructors_example = 
	| Pos of int
	| Neg of int
	| Zero

type payload_example = int * bool * string
\end{lstlisting}

$case$ represents a case of the \emph{match...with} construction when we do pattern matching.
It is constituted by two parts, a pattern and an expression.
The pattern represents the structure that each case will compare against the "parameter" of the \emph{match...with} constructor, i.e, the left side of the arrow.
The expression corresponds to what gets executed if a given case is the chosen one, i.e, the right side of the arrow:

\begin{lstlisting}[mathescape, basicstyle=\ttfamily, columns=flexible,
                    emph={type, and, let, rec, if, then, else, mod, in, for, while, do, done, to, begin, end, assert, match, with, of, open, include,ref},
                    emphstyle=\ttfamily\bfseries\color{myorange}]
let case_example (x : int) : int = begin
  match x with
  | 0 -> 10
  | 1 -> 11
  | _ -> -1 
end
\end{lstlisting}


\FloatBarrier
\subsection{Translator and printer}
\label{subsec:translator_printer}

Before we demonstrate how our translator and printer work by applying WhyRel's translation \hyperref[fig:translation-biprograms-rules]{rules}, there are some details about our printer that we want to make clear.
Adding $\_l$ to the left side program and $\_r$ to the right side program was a printing choice that could be changed to anything the reader prefers when identifying to what program a given identifier belongs to.
Additionally, it is relevant to mention that the output code you will read below was not formatted manually to be easier to read.
bip2ml effectively prints OCaml code respecting general good indentation practices.
The choice of using 2 whitespaces for the indentation is also something that can easily change by simply setting a variable in our printer to a different value.

We will present 3 examples: the first applies rules 1, 2, 3 and 5, the second showcases rules 4, 6 and 7 and the third demonstrates rule 8.
Note that we use, in our transpiler, the rules exactly as the authors of WhyRel defined them. 
We will omit the Gospel specifications in these examples, since it is not our focus in this subsection and to avoid overloading the reader with too much information at the same time.

\begin{figure}[h]
  \centering

  \begin{subfigure}[t]{0.49\textwidth}
    \centering
    \noindent
    \begin{biplangenv}


let invert_bip (x : int) = begin
  -x
end
(*@ *)

let first_bip () = begin
  let number = 1 <|> 1 in
  let message = |_ "Hello" _| in
  let res = invert_bip (3) in
  res <|> res
end
(*@ *)
    \end{biplangenv}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
    \centering
    \noindent
    \begin{gospel}


let invert_ocaml (x : int) =
  -x 
(*@ *)

let first_ocaml () = begin
  let number_l = 1 in
  let number_r = 1 in
  let message_l = "Hello" in
  let message_r = "Hello" in
  let res = invert_ocaml (3) in
  (res_l, res_r)
end
(*@ *)
    \end{gospel}
  \end{subfigure}
  \caption{Translation example for rules 1, 2, 3 and 5.}
  \label{fig:trans_ex_first}
\end{figure}

Before we explain the translations line by line, there are two notices.
The names of the functions are different depending if they belong to the input or output; bip2ml does not apply this renaming, we did it to avoid confusion.
Also, observe that each line of $first\_bip$ represents a different rule and the first two also represent rule 5.

The first line of code of that function, \emph{let number = 1 <|> 1 in}, uses rule 5 to rename the variables declared inside a $let...in$, with the same identifier and separated by a pipe.
Therefore, in the OCaml version, we get the lines \emph{let number\_l = 1 in let number\_r = 1 in}.
The next line, \emph{let message = |\_ "Hello" \_| in}, makes use of rule number 3 to translate the expression inside the floors into a pipe with two equal expressions on each side.
This shows that every floor is a pipe, but not every pipe can be a floor.
This happens because if we have $C_1 | C_2$ and $C_1 \neq C_2$, we cannot "transform" the pipe into a floored expression; otherwise, with $C_1 = C_2$, we would be able to establish that $C_1 | C_2$ is the same as $\lfloor C_1 \rfloor$.
So, bip2ml internally translates the original line to \emph{let message = "Hello" <|> "Hello" in} and finally outputs \emph{let message\_l = "Hello" in let message\_r = "Hello" in}, as we can see in the OCaml code.
Rule 2 is the next being used, since we have a function call: \emph{let res = invert\_bip (3) in}.
NAO TAMOS A USAR A REGRA 2 BEM??? SE PASSARMOS UM IDENTIFICADOR QUE EXISTE PARA OS DOIS PROGRAMAS, O QUE ACONTECE? DUPLICA SE A CHAMADA PARA CADA ARG?
In this situation, the output is no different from the input.
Finally, in the last line of $first\_bip$, \emph{res <|> res}, we utilized rule 1, which translates two expressions separated by a pipe into two sequential expressions in general.
In this particular case, however, since this is the value returned by the function, it returns them as a binary tuple, with the adequate identifier renaming: \emph{(res\_l, res\_r)}.

\begin{figure}[h]
  \centering

  \begin{subfigure}[t]{0.49\textwidth}
    \centering
    \noindent
    \begin{biplangenv}

      
let second_bip (|_c : bool _|,
  n : int) : |_int_| = begin

  if |_c_| 
  then begin |_1_| end
  else begin 
    let i = |_ ref 0 _| in
    let res = |_ ref 0 _| in

    while |_ !i < n _| do
      i := |_ !i + 1 _|;
      res := |_ !res * !i _|
    done;

    |_ !res _|
  end
end
    \end{biplangenv}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\textwidth}
    \centering
    \noindent
    \begin{gospel}


let second_ocaml (c_l : bool)
  (c_r : bool) (n_l : int)
  (n_r : int) : int * int =

  assert ( (c_l) = (c_r) );
  if c_l
  then begin 
    (1, 1)
  end else begin 
    let i_l = ref (0) in
    let i_r = ref (0) in
    let res_l = ref (0) in
    let res_r = ref (0) in

    while (!i_l < n_l) do
      i_l := (!i_l + 1);
      i_r := (!i_r + 1);
      res_l := (!res_l * !i_l);
      res_r := (!res_r * !i_r)
    done;

    (!res_l, !res_r)
  end
    \end{gospel}
  \end{subfigure}
  \caption{Translation example for rules 4, 6 and 7.}
  \label{fig:trans_ex_second}
\end{figure}

TODO: continue here
Attent to the use of floors in the parameters and on the type returned by the function.



\iffalse
Proving the equivalence of two different OCaml programs can be a hard task, depending on the complexity and size of said programs.
Therefore, we implemented a small set of simple programs that show two different ways of establishing program equivalence.
The first one relies on including a post-condition that states that the result of program P$_1$ is equal to the result of program P$_2$ for the same input.
The second way uses product programs, where we present the source and the transformed programs.
Then, we apply \hyperref[fig:product_construction_equal_struct]{these} rules to create the corresponding product program, which can be proven with standard verification.

\FloatBarrier
\section{Simple equivalence proofs}
\label{sec:results_eq_proofs}

In this section, we present the functional and imperative implementations of each algorithm.
We also compare the specification of each implementation, pointing the similarities and differences.
All of the following programs have been verified using \hyperref[sec:cameleer]{Cameleer} and the information in the tables was provided by \hyperref[sec:why3]{Why3}.


\subsection{Factorial}
\label{sub:factorial}

Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
They differ, however, in the post condition, which is \emph{result = fact n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has an invariant, \emph{!res = fact (i-1)}. 

\bigskip
\newcommand{\provername}[1]{\cellcolor{yellow!25}
\begin{sideways}\textbf{#1}~~\end{sideways}}
\newcommand{\explanation}[1]{\cellcolor{yellow!13}lemma \texttt{#1}}
\newcommand{\transformation}[1]{\cellcolor{yellow!13}transformation \texttt{#1}}
\newcommand{\subgoal}[2]{\cellcolor{yellow!13}subgoal #2}
\newcommand{\valid}[1]{\cellcolor{green!13}#1}
\newcommand{\unknown}[1]{\cellcolor{red!20}#1}
\newcommand{\invalid}[1]{\cellcolor{red!50}#1}
\newcommand{\timeout}[1]{\cellcolor{red!20}(#1)}
\newcommand{\outofmemory}[1]{\cellcolor{red!20}(#1)}
\newcommand{\noresult}{\multicolumn{1}{>{\columncolor[gray]{0.8}}c|}{~}}
%\newcommand{\failure}{\cellcolor{red!20}failure}
\newcommand{\highfailure}{\cellcolor{red!50}FAILURE}
    
\begin{minipage}{\linewidth}
\begin{gospel}
  (*@ function rec fact (n: integer) : integer =
  if n = 0 then 1 else n * fact (n-1) *)
  (*@ requires n >= 0 
    variant n *)
\end{gospel}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{ocamlenv}
  let fact_iter (n: int) : int =
    if n <= 1 then 1
    else
      begin 
        let res = ref 1 in
        for i = 2 to n do
          (*@ invariant !res = fact (i-1) *)
          res := !res * i
        done;
        !res
      end
  (*@ result = fact_iter n
    requires n >= 0 
    ensures result = fact n *)
\end{ocamlenv}
\end{minipage}

Regarding the proof of both the implementations of the factorial, Z3 was able to discard all of the verification conditions (VCs) automatically.
Furthermore, this SMT solver took a quarter of a second to complete the whole proof, verifying the functional implementation in 0.08 seconds and the imperative implementation in 0.17 seconds.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
  \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
  \hline
  \explanation{VC for fact}  & \explanation{variant decrease} & \valid{0.03} \\ 
  \cline{2-3}
    & \explanation{precondition} & \valid{0.05} \\ 
  \hline
  \explanation{VC for fact\_iter}  & \explanation{postcondition} & \valid{0.04} \\ 
  \cline{2-3}
    & \explanation{loop invariant init} & \valid{0.05} \\ 
  \cline{2-3}
    & \explanation{loop invariant preservation} & \valid{0.04} \\ 
  \cline{2-3}
    & \explanation{postcondition} & \valid{0.01} \\ 
  \cline{2-3}
    & \explanation{VC for fact\_iter} & \valid{0.03} \\ 
  \hline 
\end{tabular}
\caption{Factorial implementations verification results.}
\end{center}
\end{table}


\subsection{Fibonacci}
\label{sub:fibonacci}

Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
They differ, however, in the post condition, which is \emph{result = fib n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has two invariants, \emph{!prev = fib (i-2)} and \emph{!res = fib (i-1)}. 

\begin{minipage}{\linewidth}
\begin{gospel}
  (*@ function rec fib (n: integer) : integer =
  if n <= 1 then n else fib (n-1) + fib (n-2) *)
  (*@ requires n >= 0 
    variant n *)
\end{gospel}
\end{minipage}

\bigskip

\begin{minipage}{\linewidth}
\begin{ocamlenv}
  let fib_iter (n: int) : int =
    if n <= 1 then n
    else
      begin
        let prev = ref 0 in 
        let res = ref 1 in
        let temp = ref 1 in

        for i = 2 to n do
          (*@ invariant !prev = fib (i-2)
            invariant !res = fib (i-1) *)
          temp := !res;
          res := !res + !prev;
          prev := !temp;
        done;

        !res
      end
  (*@ result = fib_iter n
    requires n >= 0 
    ensures result = fib n *)
\end{ocamlenv}
\end{minipage}

\bigskip

Using Z3 as we did with the factorial, we were able to prove the correctness of both implementations without any human intervention, taking a total of 0.3 seconds.
Besides that, the SMT solver spent 0.13 seconds verifying the functional implementation and 0.17 seconds verifying the imperative implementation.

\begin{table}[!h]
  \begin{center}
  \begin{tabular}{|l|l|l|l|c|}
    \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
    \hline
    \explanation{VC for fib}  & \explanation{variant decrease} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{precondition} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{variant decrease} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{precondition} & \valid{0.04} \\ 
    \hline
    \explanation{VC for fib\_iter}  & \explanation{postcondition} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{loop invariant init} & \valid{0.02} \\ 
    \cline{2-3}
      & \explanation{loop invariant init} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{loop invariant preservation} & \valid{0.02} \\ 
    \cline{2-3}
      & \explanation{loop invariant preservation} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{postcondition} & \valid{0.01} \\ 
    \cline{2-3}
      & \explanation{VC for fib\_iter} & \valid{0.03} \\ 
    \hline 
  \end{tabular}
  \caption{Fibonacci implementations verification results.}
\end{center}
\end{table}


\section{Equivalence proofs using product programs}
\label{sec:results_eq_proofs_pp}

In this section, we present a program and a slightly different version.
Then we combine them using the technique of product programs, more specifically, \hyperref[fig:product_construction_equal_struct]{these} rules. 
Finally, we verified those product programs using the \hyperref[sec:why3]{Why3} tool.
The results present on the tables were generated by that tool.
All the code is written in WhyML.


\subsection{Program based on assignments}
\label{sub:results_assignments}

The (original) program is based on only two assignment instructions: \emph{y := x + 1;} and \emph{z := y + 1;}.
Despite being a very simple example, it is enough to show the usage of the product construction rules in practice.

To make the programs separable, we renamed \emph{x}, \emph{y} and \emph{z} in the original program to \emph{x1}, \emph{y1} and \emph{z1} and in the transformed program to \emph{x2}, \emph{y2} and \emph{z2}.
The product program establishes that, if the values of the variables \emph{x1} and \emph{x2} are the same before the function \emph{product} starts, it is guaranteed that \emph{y1 = y2} and \emph{z1 = z2}.
And, since there is no assignment to any of the x-components, \emph{x1 = x2} will also be true if the pre-condition is respected.

There was no need for human intervention in verifying the product program, as the SMT solver Z3 completed the proof in under a second.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Original program}
      \begin{whylang}
        use int.Int
      
        val ref x : int
        val ref y : int
        val ref z : int
      
        let original ()
          =
          y <- x + 1; 
          z <- y + 1;
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Transformed program}
      \begin{whylang}
        use int.Int
      
        val ref x : int
        val ref y : int
        val ref z : int
      
        let transformed ()
          =
          z <- x + 2; 
          y <- z - 1;
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.9\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Product program}
      \begin{whylang}
        use int.Int
      
        val ref x1 : int
        val ref x2 : int
        val ref y1 : int
        val ref y2 : int
        val ref z1 : int
        val ref z2 : int
      
        let product ()
          requires { x1 = x2 }
          ensures { y1 = y2 }
          ensures { z1 = z2 }
          =
          y1 <- x1 + 1; 
          z2 <- x2 + 2;
          z1 <- y1 + 1;
          y2 <- z2 - 1;
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \caption{Program based on assignments.}
  \label{fig:pp_ex_assignments}
\end{figure}

\begin{table}[!h]
  \begin{center}
  \begin{tabular}{|l|l|l|l|c|}
    \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
    \hline
    \explanation{VC for product}  & \explanation{postcondition} & \valid{0.01} \\ 
    \cline{2-3}
    & \explanation{postcondition} & \valid{0.00} \\ 
    \hline 
  \end{tabular}
  \caption{Program based on assignments verification results.}
  \end{center}
\end{table}  


\FloatBarrier
\subsection{Program with a while loop}
\label{sub:results_while}

This program, already mentioned \hyperref[fig:induction_var_strength_red]{before}, is slightly more complex than the example before, as this one features a while loop.
The optimization here comes from the fact that, for a computer, a multiplication is more expensive than an addition, especially when performed inside a loop.
This is called induction variable strength reduction.

The product program does not need a pre-condition, but its post.condition states that \emph{x = x'} at the end of the execution.
So, how is this achieved?
Well, with one variant to prove termination and three invariants to guarantee the post-condition; one of them is the exact same comparison (\emph{invariant \{x = x'\}}).

The proof was completed automatically by Z3 and the total duration was 0.16 seconds.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Original program}
      \begin{whylang}
        use int.Int

        let source (b c n: int) : (x: int)
        = let ref i = 0 in
          let ref j = 0 in
          let ref x = 0 in
          while i < n do
            j <- i * b + c;
            x <- x + j;
            i <- i + 1;
          done;
          x
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.45\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Transformed program}
      \begin{whylang}
        use int.Int

        let transformed (b c n: int) : (x': int)
        = let ref i' = 0 in
          let ref j' = c in
          let ref x' = 0 in
          while i' < n do
            x' <- x' + j';
            j' <- j' + b;
            i' <- i' + 1
          done;
          x'
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.9\textwidth}
    \begin{minipage}[t]{\linewidth}
      \textbf{Product program}
      \begin{whylang}
        use int.Int

        let product (b c n: int) : (x: int, x': int)
          ensures { x = x' }
        = let ref i = 0 in
          let ref i' = 0 in
          let ref j = 0 in
          let ref j' = c in
          let ref x = 0 in
          let ref x' = 0 in
          while i < n && i' < n do
            variant   { n - i }
            invariant { j' = i' * b + c }
            invariant { i = i' }
            invariant { x = x' }
            j <- i * b + c;
            x <- x + j;
            i <- i + 1;
            x' <- x' + j';
            j' <- j' + b;
            i' <- i' + 1
          done;
          x, x'
      \end{whylang}
    \end{minipage}
  \end{subfigure}
  \caption{Program with a while loop.}
  \label{fig:pp_ex_while}
\end{figure}

\begin{table}[!h]
  \begin{center}
    \begin{tabular}{|l|l|l|l|c|}
      \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
      \hline
      \explanation{VC for main}  & \explanation{loop invariant init} & \valid{0.01} \\ 
      \cline{2-3}
       & \explanation{loop invariant init} & \valid{0.02} \\ 
      \cline{2-3}
       & \explanation{loop invariant init} & \valid{0.02} \\ 
      \cline{2-3}
       & \explanation{loop variant decrease} & \valid{0.02} \\ 
      \cline{2-3}
       & \explanation{loop invariant preservation} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{loop invariant preservation} & \valid{0.01} \\ 
      \cline{2-3}
       & \explanation{loop invariant preservation} & \valid{0.04} \\ 
      \cline{2-3}
       & \explanation{postcondition} & \valid{0.01} \\ 
      \hline 
    \end{tabular}
  \caption{Program with a while loop verification results.}
\end{center}
\end{table}    
\fi
