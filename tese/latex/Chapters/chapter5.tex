%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter5.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter5.tex}%

%% Estrutura:
%% intro (aprofundar um pouco)
%% background (igual + aprofundar whyrel + dune)
%% state of the art (igual)
%% methodology (explicar a ferramenta)
%% case studies (exemplos mais importantes)
%% conclusion and future work

\chapter{Case Studies}
\label{cha:case_studies}

In this chapter, we showcase several case studies that we used to explore the capabilities of the transpiler developed in this thesis.
We start by analyzing case studies in which BipLang has no significant difference from other programming languages other than syntax.
Then, we present some examples of what BipLang adds that OCaml cannot do.
Finally, we focus on case studies that are more complex and, therefore, demonstrate the real potential of our tool.
TODO: WRITE PROOF AND ADD ITS BENCHMARK FOR ALL OF THE CODE EXAMPLES. 


\section{The Foundations}
\label{sec:foundations}

This section lists some simple programs that could be written in any other programming language, but shows how it is done in BipLang.

%Multiplies two non-negative numbers using nested loops.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let mult (n : int, m : int) = begin
    let result = ref 0 in
    let j = ref 0 in

    for i = 0 to n-1 do
      while !j < m do
        result := !result + 1;
        j := !j + 1
      done;
      j := 0;
    done;
    
    !result
  end
  (*@ ensures true *)
\end{biplangenv}
\end{minipage}
\caption{Using nested loops to multiply two (non-negative) numbers.}
\end{figure}
% TODO: put more space

%Demonstrating the use of the match and assert constructions.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let match_assert (x : int) = begin
    let res = 
      match x with 
      | 0 -> 10
      | 1 -> 20
      | _ -> 0
    in
    assert (res >= 0);
    res
  end
  (*@ ensures true *) 
\end{biplangenv}
\end{minipage}
\caption{The match and assert constructions.}
\end{figure}
% TODO: put more space

%Showcasing the presence of nested functions through the use of function applying.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let nested_fun_apply () : int = begin
    let x = 10 in

    let inner_fun (i : int) : int = begin
      x * i 
    end
    (*@ ensures true *)
    in

    let i = ref 2 in
    inner_fun (!i * 5)
  end
  (*@ ensures true *) 
  (* Result: inner_fun(!i * 5) -> inner_fun(2 * 5) -> *)
  (*         inner_fun(10) -> x * i -> 10 * 10 -> 100 *)
\end{biplangenv}
\end{minipage}
\caption{Nested functions and function applying.}
\end{figure}
% TODO: put more space


\section{Incremeting OCaml}
\label{sec:incrementing}

In this section, we present examples of programs that showcase the functionalities and constructions that BipLang adds on top of OCaml.
That is accomplished by the introduction of the \bm{$\langle|\rangle$} (pipe), \bm{$\lfloor$} (left floor) and \bm{$\rfloor$} (right floor) symbols.
We also present our tool outputs so we can compare the differences between writing each of these programs using BipLang versus OCaml.


\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let floors_biplang (|_ arg1 : int _|, |_ arg2 : int _|)
    : |_ int _| = begin

    let x = |_ arg1 * 2 _| in
    let y = |_ arg2 _| in

    if |_ y > x _| then begin
      |_ x + y _|
    end else begin
      |_ x - y _|
    end
  end
  (*@ ensures true *)
\end{biplangenv}
\end{minipage}
\caption{Showcasing the use of the floor symbols (BipLang)}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let floors_ocaml (arg1_l : int) (arg1_r : int)
    (arg2_l : int) (arg2_r : int) : int * int =
    
    let x_l = (arg1_l * 2) in
    let x_r = (arg1_r * 2) in
    let y_l = arg2_l in
    let y_r = arg2_r in
    assert ( ((y_l > x_l)) = ((y_r > x_r)) );
    if (y_l > x_l)
    then begin 
      ((x_l + y_l), (x_r + y_r))
    end else begin 
      ((x_l - y_l), (x_r - y_r))
    end
  (*@ ensures true *)
\end{biplangenv}
\end{minipage}
\caption{Showcasing the use of the floor symbols (OCaml)}
\end{figure}


\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  CODE TODO
\end{biplangenv}
\end{minipage}
\caption{Showcasing the use of the pipe symbol (BipLang)}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  CODE TODO
\end{biplangenv}
\end{minipage}
\caption{Showcasing the use of the pipe symbol (OCaml)}
\end{figure}



\section{Demonstrating the Usefulness}
\label{sec:applicability}

This section illustrates the true capabilities of the transpiler through some more complex examples.
As we did in the previous section, we present these programs written in BipLang versus OCaml.
Now this really puts in evidence the applicability of our tool.

LIST: factiter, gcditer, inducvarstrengthred, condalignloops, condalignloopsnested













\iffalse
\begin{itemize}
    \setlength\itemsep{0bp}

    \item{\emph{Task 1: Collection of case studies}}\hspace{1em}
    In March, we plan to select interesting cases where applying our work would be beneficial. 
    Some examples are compiler optimizations (and optimizations in general), reduction of higher-order functions to first-order and even code versioning, in the sense that refactoring or new features do not modify the behavior of previously correct code.

    \item \emph{Task 2: First-order product programs for OCaml}\hspace{1em} 
    Afterwards, and spanning across a month and a half, we will adapt the original work of product programs (which is based on the \emph{while} language) to the reality of OCaml, in the first-order context.

    \item \emph{Task 3: First-order implementation in Cameleer}\hspace{1em} 
    During two months, we plan on implementing the first-order OCaml approach in the Cameleer tool.

    \item \emph{Task 4: Extension of product programs to higher-order}\hspace{1em} 
    After that, in the month of July, we plan to extend our notion of product programs in OCaml to include some higher-order constructs focused on iteration, such as folds (left and right), map and iter.

    \item \emph{Task 5: Higher-order implementation in Cameleer}\hspace{1em} 
    In the following month, we will attempt to extend the implementation of product programs in Cameleer to include the higher-order functions mentioned in the previous task.

    \item \emph{Task 6: Dissertation Writing}\hspace{1em} 
    Finally, we will dedicate the entire month of September to write the dissertation.

\end{itemize}
  
\begin{figure}[h]
\tikzset{every picture/.style={xscale=0.65,yscale=0.65,transform shape}}
\begin{ganttchart}[ y unit chart = 0.6cm,
                      vgrid,
                      bar top shift=-0.1,
                      bar height=0.6,
                      title height=0.7]{1}{28}
    \gantttitle{March}{4}
    \gantttitle{April}{4}
    \gantttitle{May}{4}
    \gantttitle{June}{4}
    \gantttitle{July}{4}
    \gantttitle{August}{4}
    \gantttitle{September}{4}\\
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1} \\
  
  \ganttgroup{Preliminary}{1}{4} \\
  \ganttbar{Collection of case studies}{1}{4} \\
  
  \ganttgroup{First-order product programs}{5}{16} \\
  \ganttbar{Definition in OCaml}{5}{10} \\
  \ganttbar{Implementation in Cameleer}{9}{16} \\

  \ganttgroup{Extension to higher-order}{17}{24} \\
  \ganttbar{Definition in OCaml}{17}{20} \\
  \ganttbar{Implementation in Cameleer}{21}{24} \\
  
  \ganttgroup{Dissertation}{25}{28} \\
  \ganttbar{Writing}{25}{28}
  
  \end{ganttchart}
  \caption{Planned Schedule.}
  \label{ganttchart}
\end{figure}
\fi
