%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter5.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter5.tex}%

%% Estrutura:
%% intro (aprofundar um pouco)
%% background (igual + aprofundar whyrel + dune)
%% state of the art (igual)
%% methodology (explicar a ferramenta)
%% case studies (exemplos mais importantes)
%% conclusion and future work

\chapter{Case Studies}
\label{cha:case_studies}

In this chapter, we showcase several case studies that we used to explore the capabilities of the transpiler developed in this thesis.
We start by analyzing case studies in which BipLang has no significant difference from other programming languages other than syntax.
Then, we present some examples of what BipLang adds that OCaml cannot do.
Finally, we focus on case studies that are more complex and, therefore, demonstrate the real potential of our tool.
TODO: WRITE PROOF AND ADD ITS BENCHMARK FOR ALL OF THE CODE EXAMPLES. 


\section{The Foundations}
\label{sec:foundations}

This section lists some simple programs that could be written in any other 
programming language, but shows how it is done in BipLang.

%Multiplies two non-negative numbers using nested loops.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let mult_biplang (n : int, m : int) = begin
    let res = ref 0 in
    let j = ref 0 in

    for i = 0 to n-1 do
      (*@ invariant 0 <= i && i <= n
          invariant !j = 0
          invariant !res = m * i + !j *)

      while !j < m do
        (*@ invariant 0 <= !j && !j <= m
            invariant !res = m * i + !j
            variant   m - !j *)

        res := !res + 1;
        j := !j + 1
      done;

      j := 0
    done;
    
    !res
  end
  (*@ requires n >= 0 && m >= 0
      ensures  result = n * m *)
\end{biplangenv}
\end{minipage}
\caption{Using nested loops to multiply two (non-negative) numbers (BipLang)}
\end{figure}
% TODO: put more space

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  let mult_ocaml (n : int) (m : int) =
    let res = ref (0) in
    let j = ref (0) in

    for i = 0 to (n - 1) do
      (*@ invariant 0 <= i && i <= n
          invariant !j = 0
          invariant !res = m * i + !j *)

      while (!j < m) do
        (*@ invariant 0 <= !j && !j <= m
            invariant !res = m * i + !j
            variant   m - !j *)
        res := (!res + 1);
        j := (!j + 1)
      done;

      j := 0
    done;

    !res
  (*@ requires n >= 0 && m >= 0
      ensures  result = n * m *)
\end{gospel}
\end{minipage}
\caption{Using nested loops to multiply two (non-negative) numbers (OCaml)}
\end{figure}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for mult\_ocaml}  & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{VC for mult\_ocaml} & \valid{0.03} \\ 
\hline 
\end{tabular}
\caption{Multiply two (non-negative) numbers (OCaml) verification results}
\end{center}
\end{table}


%Demonstrating the use of the match and assert constructions.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  type number = 
    | Pos of int
    | Neg of int
    | Zero

  let match_assert_type_biplang (x : int) : int = begin
    let y = 
      if x > 0 then begin Pos (x) end
      else begin
        if x < 0 then begin Neg x end
        else begin Zero end
      end
    in  

    let res = (
      match y with
      | Pos n -> (n * 10)
      | Neg (n) -> (n * 2)
      | Zero -> 0
    ) in
    
    let expr_to_assert = (res == (x * 2)) || (res == (x * 10)) in
    assert (expr_to_assert);
    res
  end
  (*@ ensures x > 0 -> result = x * 10
      ensures x = 0 -> result = 0
      ensures x < 0 -> result = x * 2 *)
\end{biplangenv}
\end{minipage}
\caption{The match, assert and type constructions (BipLang)}
\end{figure}
% TODO: put more space

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  type number =
    | Pos of int
    | Neg of int
    | Zero

  let match_assert_type_ocaml (x : int) : int =
    let y = 
      if (x > 0)
      then begin 
        Pos (x)
      end else begin 
        if (x < 0)
        then begin 
          Neg (x)
        end else begin 
          Zero
        end
      end
    in
    let res = (
      match y with
      | Pos (n) -> (n * 10)
      | Neg (n) -> (n * 2)
      | Zero -> 0
    ) in
    let expr_to_assert = ((res = (x * 2)) || (res = (x * 10))) in
    assert (expr_to_assert);
    res
  (*@ ensures x > 0 -> result = x * 10
      ensures x = 0 -> result = 0
      ensures x < 0 -> result = x * 2 *)
\end{gospel}
\end{minipage}
\caption{The match, assert and type constructions (OCaml)}
\end{figure}
% TODO: put more space

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for match\_assert\_type\_ocaml}  & \explanation{assertion} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.05} \\ 
\hline
\end{tabular}
\caption{The match, assert and type constructions (OCaml) verification results}
\end{center}
\end{table}


%Showcasing the presence of nested functions through the use of function applying.
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let nested_funs_biplang (arg) : int = begin
    let x = 10 in

    let inner_fun (i : int) : int = begin
      x * i 
    end
    (*@ ensures result = x * i *)
    in

    inner_fun (arg * 5) 
  end
  (*@ ensures result = 50 * arg *)  
\end{biplangenv}
\end{minipage}
\caption{Nested functions and function applying (BipLang)}
\end{figure}
% TODO: put more space

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  let nested_funs_ocaml (arg) : int =
    let x = 10 in

    let inner_fun (i : int) : int =
      (x * i)
    (*@ ensures result = x * i *)
    in
      
    inner_fun ((arg * 5))
  (*@ ensures result = 50 * arg *)  
\end{gospel}
\end{minipage}
\caption{Nested functions and function applying (OCaml)}
\end{figure}
% TODO: put more space

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for nested\_funs\_ocaml}  & \explanation{postcondition} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.03} \\ 
\hline
\end{tabular}
\caption{Nested functions and function applying (OCaml) verification results}
\end{center}
\end{table}



\section{Incremeting OCaml}
\label{sec:incrementing}

In this section, we present examples of programs that showcase the functionalities and constructions that BipLang adds on top of OCaml.
That is accomplished by the introduction of the \bm{$\langle|\rangle$} (pipe), \bm{$\lfloor$} (left floor) and \bm{$\rfloor$} (right floor) symbols.
We also present our tool outputs so we can compare the differences between writing each of these programs using BipLang versus OCaml.

% TODO why does this figure appear before the text above??
\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let pipe_biplang (x : int <|> x : int) = begin
    let y = 10 <|> 1 in
    let z = 10 <|> 100 in
    let res = x * y * z <|> x * y * z in
    res <|> res
  end
  (*@ requires x_l = x_r
      ensures  match result with (l_res, r_res) -> 
                (l_res = r_res && l_res = x_l * 100) *)
\end{biplangenv}
\end{minipage}
\caption{Showcasing the use of the pipe symbol (BipLang)}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  let pipe_ocaml (x_l : int) (x_r : int) =
    let y_l = 10 in
    let y_r = 1 in
    let z_l = 10 in
    let z_r = 100 in
    let res_l = ((x_l * y_l) * z_l) in
    let res_r = ((x_r * y_r) * z_r) in
    (res_l, res_r)
  (*@ requires x_l = x_r
      ensures  match result with (l_res, r_res) -> 
                (l_res = r_res && l_res = x_l * 100) *)
\end{gospel}
\end{minipage}
\caption{Showcasing the use of the pipe symbol (OCaml)}
\end{figure}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for pipe\_ocaml}  & \explanation{postcondition} & \valid{0.03} \\ 
\hline
\end{tabular}
\caption{Showcasing the use of the pipe symbol (OCaml) verification results}
\end{center}
\end{table}


\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let floors_biplang (|_ arg1 : int _|, |_ arg2 : int _|)
    : |_ int _| = begin

    let x = |_ arg1 * 2 _| in
    let y = |_ arg2 _| in

    if |_ y > x _| then begin
      |_ x + y _|
    end else begin
      |_ x - y _|
    end
  end
  (*@ requires arg1_l = arg1_r && arg2_l = arg2_r
      ensures  match result with (l_res, r_res) -> 
                (l_res = r_res && l_res = (
                  if arg2_l > arg1_l * 2
                  then arg1_l * 2 + arg2_l
                  else arg1_l * 2 - arg2_l)) *)
\end{biplangenv}
\end{minipage}
\caption{Demonstrating the use of the floor symbols (BipLang)}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  let floors_ocaml (arg1_l : int) (arg1_r : int)
    (arg2_l : int) (arg2_r : int) : int * int =
    
    let x_l = (arg1_l * 2) in
    let x_r = (arg1_r * 2) in
    let y_l = arg2_l in
    let y_r = arg2_r in
    assert ( ((y_l > x_l)) = ((y_r > x_r)) );

    if (y_l > x_l)
    then begin 
      ((x_l + y_l), (x_r + y_r))
    end else begin 
      ((x_l - y_l), (x_r - y_r))
    end
  (*@ requires arg1_l = arg1_r && arg2_l = arg2_r
      ensures  match result with (l_res, r_res) -> 
                (l_res = r_res && l_res = (
                  if arg2_l > arg1_l * 2
                  then arg1_l * 2 + arg2_l
                  else arg1_l * 2 - arg2_l)) *)
\end{gospel}
\end{minipage}
\caption{Demonstrating the use of the floor symbols (OCaml)}
\end{figure}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for floors\_ocaml}  & \explanation{assertion} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.05} \\ 
\hline
\end{tabular}
\caption{Demonstrating the use of the floor symbols (OCaml) verification results}
\end{center}
\end{table}


\section{Demonstrating the Usefulness}
\label{sec:usefulness}

This section illustrates the applicability of our tool through some more complex examples.
As we did in the previous section, we present these programs written in BipLang versus OCaml.

LIST: mais?
factiter, gcditer, inducvarstrengthred, condalignloops, condalignloopsnested

REFERENCIAR FIGURE 3.4 COM O CODIGO ORIGINAL DA inducvarstrengthred

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  let induc_var_strength_red_biplang
    (|_b : int_|, |_c : int_|, |_n : int_|)
    : |_int_| = begin

    let i = |_ ref 0 _| in
    let j = ref 0 <|> ref c in
    let x = |_ ref 0 _| in

    while |_ !i < n _| do
      (*@ invariant !i_l >= 0 && !i_r >= 0 && !i_l = !i_r
          invariant n_l >= 0 -> !i_l <= n_l
          invariant !j_r = !i_r * b_r + c_r
          invariant !x_l = !x_r 
          variant n_l - !i_l *)
      j := !i * b + c <|> x := !x + !j;
      x := !x + !j    <|> j := !j + b;
      i := |_ !i + 1 _|
    done;

    |_ !x _|
  end
  (*@ requires b_l = b_r && c_l = c_r && n_l = n_r
      ensures  match result with (l_res, r_res) -> l_res = r_res *) 
\end{biplangenv}
\end{minipage}
\caption{Induction variable strength reduction (BipLang)}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  let induc_var_strength_red_ocaml
    (b_l : int) (b_r : int) (c_l : int) (c_r : int)
    (n_l : int) (n_r : int) : int * int =
    
    let i_l = ref (0) in
    let i_r = ref (0) in
    let j_l = ref (0) in
    let j_r = ref (c_r) in
    let x_l = ref (0) in
    let x_r = ref (0) in

    while (!i_l < n_l) do
      (*@ invariant ((!i_l < n_l)) <-> ((!i_r < n_r))
          invariant !i_l >= 0 && !i_r >= 0 && !i_l = !i_r
          invariant n_l >= 0 -> !i_l <= n_l
          invariant !j_r = !i_r * b_r + c_r
          invariant !x_l = !x_r 
          variant n_l - !i_l *)
      j_l := ((!i_l * b_l) + c_l);
      x_r := (!x_r + !j_r);
      x_l := (!x_l + !j_l);
      j_r := (!j_r + b_r);
      i_l := (!i_l + 1);
      i_r := (!i_r + 1)
    done;

    (!x_l, !x_r)
  (*@ requires b_l = b_r && c_l = c_r && n_l = n_r
      ensures  match result with (l_res, r_res) -> l_res = r_res *)
\end{gospel}
\end{minipage}
\caption{Induction variable strength reduction (OCaml)}
\end{figure}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for induc\_var\_strength\_red\_ocaml}  & \explanation{loop invariant init} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.03} \\ 
\hline
\end{tabular}
\caption{Induction variable strength reduction (OCaml) verification results}
\end{center}
\end{table}


REFERENCIAR FIGURE DO CODIGO DOS 
condalignloops DA SECCAO DO WHYREL

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}
  TODO: prova ainda nao passa!

  (*@ axiom mult: forall a:int, b:int, c:int, d:int.
     0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b ->
     c > d -> (a * c) > (b * d) *) 
    
  let cond_align_loops_biplang (|_x : int_|, |_n : int_|)
    : |_int_| = begin

    let y = |_ ref x _| in
    let z = ref 24 <|> ref 16 in 
    let w = |_ ref 0 _| in

    while !y > 4 <|> !y > 4 . (!w mod 2 <> 0) <|> (!w mod 2 <> 0) do
      (*@ variant   !y_l + !y_r
          invariant !y_l = !y_r && !y_r >= 4
          invariant !z_l > !z_r && !z_l > 0 && !z_r > 0 *)

      if ((!w mod n == 0) <|> (!w mod n == 0)) then begin
        z := (!z * !y <|> !z * 2);
        y := |_ !y - 1 _|
      end else begin () end;

      w := |_ !w + 1 _|
    done; 

    |_ !z _|
  end
  (*@ requires x_l = x_r && n_l = n_r && n_r > 0 && x_l >= 4
      ensures  match result with (l_res, r_res) -> l_res > r_res *)  
\end{biplangenv}
\end{minipage}
\caption{Conditionally aligned loops (BipLang)}
\end{figure}
% TODO: put more space

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}
  TODO: 
  prova ainda nao passa!
  codigo nao cabe numa pagina!

  (*@ axiom mult: forall a:int, b:int, c:int, d:int.
     0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b ->
     c > d -> (a * c) > (b * d) *)

  let cond_align_loops_ocaml (x_l : int) (x_r : int)
    (n_l : int) (n_r : int) : int * int =

    let y_l = ref (x_l) in
    let y_r = ref (x_r) in
    let z_l = ref (24) in
    let z_r = ref (16) in
    let w_l = ref (0) in
    let w_r = ref (0) in

    while ((!y_l > 4) || (!y_r > 4)) do
      (*@ variant   !y_l + !y_r
          invariant !y_l = !y_r && !y_r >= 4
          invariant !z_l > !z_r && !z_l > 0 && !z_r > 0
          invariant (!y_l > 4 && mod !w_l 2 <> 0) ||
                    (!y_r > 4 && mod !w_r 2 <> 0) ||
                    (not (!y_l > 4) && not (!y_r > 4)) || 
                    (!y_l > 4 && !y_r > 4) *)
      if ((!y_l > 4) && ((!w_l mod 2) <> 0))
      then begin 
        if ((!w_l mod n_l) = 0)
        then begin 
          z_l := (!z_l * !y_l);
          y_l := (!y_l - 1)
        end else begin 
          ()
        end;
        w_l := (!w_l + 1)
      end else begin 
        if ((!y_r > 4) && ((!w_r mod 2) <> 0))
        then begin 
          if ((!w_r mod n_r) = 0)
          then begin 
            z_r := (!z_r * 2);
            y_r := (!y_r - 1)
          end else begin 
            ()
          end;
          w_r := (!w_r + 1)
        end else begin 
          assert ( (((!w_l mod n_l) = 0)) = (((!w_r mod n_r) = 0)) );
          if ((!w_l mod n_l) = 0)
          then begin 
            z_l := (!z_l * !y_l);
            z_r := (!z_r * 2);
            y_l := (!y_l - 1);
            y_r := (!y_r - 1)
          end else begin 
            ()
          end;
          w_l := (!w_l + 1);
          w_r := (!w_r + 1)
        end
      end
    done;

    (!z_l, !z_r)
  (*@ requires x_l = x_r && n_l = n_r && n_r > 0 && x_l >= 4
      ensures  match result with (l_res, r_res) -> l_res > r_res *) 
\end{gospel}
\end{minipage}
\caption{Conditionally aligned loops (OCaml)}
\end{figure}
% TODO: put more space

\iffalse\begin{table}[!h]
\begin{center}

\end{tabular}
\caption{Conditionally aligned loops (OCaml) verification results}
\end{center}
\end{table}
\fi






\iffalse
\begin{itemize}
    \setlength\itemsep{0bp}

    \item{\emph{Task 1: Collection of case studies}}\hspace{1em}
    In March, we plan to select interesting cases where applying our work would be beneficial. 
    Some examples are compiler optimizations (and optimizations in general), reduction of higher-order functions to first-order and even code versioning, in the sense that refactoring or new features do not modify the behavior of previously correct code.

    \item \emph{Task 2: First-order product programs for OCaml}\hspace{1em} 
    Afterwards, and spanning across a month and a half, we will adapt the original work of product programs (which is based on the \emph{while} language) to the reality of OCaml, in the first-order context.

    \item \emph{Task 3: First-order implementation in Cameleer}\hspace{1em} 
    During two months, we plan on implementing the first-order OCaml approach in the Cameleer tool.

    \item \emph{Task 4: Extension of product programs to higher-order}\hspace{1em} 
    After that, in the month of July, we plan to extend our notion of product programs in OCaml to include some higher-order constructs focused on iteration, such as folds (left and right), map and iter.

    \item \emph{Task 5: Higher-order implementation in Cameleer}\hspace{1em} 
    In the following month, we will attempt to extend the implementation of product programs in Cameleer to include the higher-order functions mentioned in the previous task.

    \item \emph{Task 6: Dissertation Writing}\hspace{1em} 
    Finally, we will dedicate the entire month of September to write the dissertation.

\end{itemize}
  
\begin{figure}[h]
\tikzset{every picture/.style={xscale=0.65,yscale=0.65,transform shape}}
\begin{ganttchart}[ y unit chart = 0.6cm,
                      vgrid,
                      bar top shift=-0.1,
                      bar height=0.6,
                      title height=0.7]{1}{28}
    \gantttitle{March}{4}
    \gantttitle{April}{4}
    \gantttitle{May}{4}
    \gantttitle{June}{4}
    \gantttitle{July}{4}
    \gantttitle{August}{4}
    \gantttitle{September}{4}\\
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1}
    \gantttitlelist{1,...,4}{1} \\
  
  \ganttgroup{Preliminary}{1}{4} \\
  \ganttbar{Collection of case studies}{1}{4} \\
  
  \ganttgroup{First-order product programs}{5}{16} \\
  \ganttbar{Definition in OCaml}{5}{10} \\
  \ganttbar{Implementation in Cameleer}{9}{16} \\

  \ganttgroup{Extension to higher-order}{17}{24} \\
  \ganttbar{Definition in OCaml}{17}{20} \\
  \ganttbar{Implementation in Cameleer}{21}{24} \\
  
  \ganttgroup{Dissertation}{25}{28} \\
  \ganttbar{Writing}{25}{28}
  
  \end{ganttchart}
  \caption{Planned Schedule.}
  \label{ganttchart}
\end{figure}
\fi
