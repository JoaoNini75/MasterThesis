%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter5.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter5.tex}%

\chapter{Case Studies}
\label{cha:case_studies}

In this chapter, we showcase several case studies that demonstrate the capabilities of the tool developed in this thesis.
We start by presenting a simple example of what BipLang can do that OCaml cannot.
Then, we focus on 3 case studies that are more complex and, therefore, demonstrate the real potential of bip2ml.


\section{Incremeting OCaml}
\label{sec:incrementing}

In this section, we give an example that showcases some of the functionalities and constructions that BipLang adds on top of OCaml.
That is accomplished by the introduction of the \bm{$\langle|\rangle$} (pipe), \bm{$\lfloor$} (left floor) and \bm{$\rfloor$} (right floor) symbols.
We also present our tool's outputs so we can compare the differences between writing each of these programs using BipLang versus direct OCaml.

Recall the $mult$ \hyperref[fig:mult_source_programs]{unary programs} and their \hyperref[fig:mult_biprogram]{biprogram}.
We also presented before its corresponding \hyperref[fig:translation_ex]{WhyML product program}, the one that would be generated by WhyRel.
Now, we rewrite the biprogram in BipLang and use our transpiler to get the generated OCaml code.
Remember, the rules applied by bip2ml are the same as the ones developed by WhyRel's authors.

As described before, the \emph{mult} biprogram combines two unary programs that multiply two non-negative integer numbers.
On the left side, that is done through two nested while loops, incrementing the result by 1 in each iteration.
On the right side, there is a single while loop with an assignment inside, making the result increment by $m$ in each cycle iteration.

The specification of $mult\_biplang$ and $mult\_ocaml$ is the same as $mult\_whyml$, but now written in GOSPEL.
Besides that, since OCaml does not support labels, we had to substitute it with a simple variable that is used later to get the value of the previous iteration.
In practice, it also works, but WhyML's labels may help the readibility in terms of separating code and specification.

The reader may have also noticed that, in $mult\_ocaml$, bip2ml declares and initializes the $j\_r$ variable but it is never used.
This can be seen as a limitation of our tool: we cannot mix "neutral" variables with "sided" ones.
We also cannot mix left side and right side variables, but that would hardly make sense in the code, although it clearly makes sense in the specification.
In this case, since the condition of the $mult\_biplang$'s inner while loop is at the left of a $pipe$, those identifiers will be transformed into left side identifiers.
So, even if we declared \emph{let j = ref 0 in}, we would still get \emph{while (!j\_l < m\_l) do}, and that would result in variables' names mismatching in the generated OCaml code.

Regarding the verification of $mult\_ocaml$, CVC5 was able to discharge all VCs automatically in a total of 410 milliseconds.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}


let mult_biplang (|_ n: int _|, |_ m: int _|) : |_ int _| = begin
  let i = |_ ref 0 _| in
  let res = |_ ref 0 _| in
	
  while |_ !i < n _| do
    (*@ variant   n_l - !i_l
        invariant !i_l = !i_r && !res_l = ! res_r *)

    let previous_res_l = !res_l in
    let j = |_ ref 0 _| in

    (( 
      while (!j < m) do
        (*@ variant   m_l - !j_l
            invariant 0 <= !j_l <= m_l && !res_l = !res_r + !j_l *)
        res := !res + 1;
        j := !j + 1
      done
    )
    <|>
    (res := !res + m));

    assert ((!res_l = previous_res_l + m_l));
    i := |_ !i + 1 _|
  done;

  |_ !res _|
end
(*@ requires n_l = n_r && m_l = m_r && m_l >= 0 
    ensures  match result with (l_res, r_res) -> l_res = r_res *)
\end{biplangenv}
\end{minipage}
\caption{$mult$ biprogram (BipLang).}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}


let mult_ocaml (n_l : int) (n_r : int) (m_l : int) (m_r : int) :
  int * int =

  let i_l = ref (0) in
  let i_r = ref (0) in
  let res_l = ref (0) in
  let res_r = ref (0) in

  while (!i_l < n_l) do
    (*@ invariant ((!i_l < n_l)) <-> ((!i_r < n_r))
        variant   n_l - !i_l
        invariant !i_l = !i_r && !res_l = ! res_r *)
    let previous_res_l = !res_l in
    let j_l = ref (0) in
    let j_r = ref (0) in    

    while (!j_l < m_l) do
      (*@ variant   m_l - !j_l
          invariant 0 <= !j_l && !j_l <= m_l && !res_l = !res_r + !j_l *)
      res_l := (!res_l + 1);
      j_l := (!j_l + 1)
    done;
    
    res_r := (!res_r + m_r);
    assert ((!res_l = (previous_res_l + m_l)));
    i_l := (!i_l + 1);
    i_r := (!i_r + 1)
  done;

  (!res_l, !res_r)
(*@ requires n_l = n_r && m_l = m_r && m_l >= 0
    ensures  match result with (l_res, r_res) -> l_res = r_res *)
\end{gospel}
\end{minipage}
\caption{$mult$ product program (OCaml).}
\end{figure}

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for mult\_ocaml}  & \explanation{loop invariant init} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{assertion} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\hline 
\end{tabular}
\caption{$mult$ product program (OCaml) verification results.}
\end{center}
\end{table}


\FloatBarrier
\section{Real World Cases}
\label{sec:usefulness}

This section illustrates the applicability of our tool through some more complex examples.
As we did in the previous section, we present these programs written in BipLang and their corresponding translations to OCaml.
The first and second examples correspond to the proof of two common compiler optimizations; while the first establishes the equivalence of the outputs of the source and optimized versions, the second case proves that a given part of the memory of the programs are in the same state when the execution finishes.
The third example is not about program equivalence, but a similar relational property: majorization.
These case studies show that bip2ml is able to reason about not only program equivalence, but other interesting properties too.


\FloatBarrier
\subsection{Induction variable strength reduction}
\label{subsec:rwc-ivsr}

The first example is a common compiler optimization, the induction variable strength reduction.
Recall the source, optimized and product \hyperref[fig:induction_var_strength_red]{programs}, presented earlier.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}


let induc_var_strength_red_biplang (|_b : int_|,
  |_c : int_|, |_n : int_|) : |_int_| = begin

  let i = |_ ref 0 _| in
  let j = ref 0 <|> ref c in
  let x = |_ ref 0 _| in

  while |_ !i < n _| do
    (*@ variant   n_l - !i_l
        invariant !i_l = !i_r 
        invariant !x_l = !x_r
        invariant !j_r = !i_r * b_r + c_r *)
    j := !i * b + c <|> x := !x + !j;
    x := !x + !j    <|> j := !j + b;
    i := |_ !i + 1 _|
  done;

  |_ !x _|
end
(*@ requires b_l = b_r && c_l = c_r && n_l = n_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *) 
\end{biplangenv}
\end{minipage}
\caption{Induction variable strength reduction (BipLang).}
\label{fig:ivsr_biplang}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}


let induc_var_strength_red_ocaml
  (b_l : int) (b_r : int) (c_l : int) (c_r : int)
  (n_l : int) (n_r : int) : int * int =
  
  let i_l = ref (0) in
  let i_r = ref (0) in
  let j_l = ref (0) in
  let j_r = ref (c_r) in
  let x_l = ref (0) in
  let x_r = ref (0) in

  while (!i_l < n_l) do
    (*@ invariant ((!i_l < n_l)) <-> ((!i_r < n_r))
        variant   n_l - !i_l
        invariant !i_l = !i_r 
        invariant !x_l = !x_r
        invariant !j_r = !i_r * b_r + c_r *)
    j_l := ((!i_l * b_l) + c_l);
    x_r := (!x_r + !j_r);
    x_l := (!x_l + !j_l);
    j_r := (!j_r + b_r);
    i_l := (!i_l + 1);
    i_r := (!i_r + 1)
  done;

  (!x_l, !x_r)
(*@ requires b_l = b_r && c_l = c_r && n_l = n_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *)
\end{gospel}
\end{minipage}
\caption{Induction variable strength reduction (OCaml).}
\label{fig:ivsr_ocaml}
\end{figure}

We start by initializing the $i$, $j$ and $x$ variables.
We use the floors for $i$ and $x$, since both sides of the program bind to them the same value (\emph{ref 0}, for both variables).
To initialize $j$, on the other hand, we use the pipe, since one side binds to it \emph{ref 0} and the other \emph{ref c}.

We then have the main part of the program: the floored while loop.
The condition of the cycle indicates that as long as \emph{!i < n} is true for both left and right, it keeps executing.
This gets translated to only the left side condition and the first invariant in the loop of the generated program, automatically introduced by our tool.
The other invariants and the variant had to be added by us.
Then, inside the loop, we have two assignments to different identifiers, which explains the slightly different syntax of the form \emph{id1 := value1 <|> id2 := value2}.
The last instruction of the while is an equal assign to both sides of the program.

Finally, we return the value inside the $x$ reference, for the left and right sides equally, which gets translated to the return of a binary tuple.

The pre-conditions and post-conditions are also provided by us.
In this case, we are simply saying that agreement on the input results in agreement of the output.
Let us look again at the loop's manually added invariants and variant. 
Since the assignments to $x$ and $i$ are the same for both sides, the invariants \emph{!i\_l = !i\_r} and \emph{!x\_l = !x\_r} are trivial, and so is the variant.
The last invariant may be the most interesting one, but it is also not complex. 
Looking at the right side, each iteration (which represents an increment of $i\_r$ by 1), we add $b\_r$ to the previous $j\_r$, and that corresponds to the multiplication of $i\_r$ by $b\_r$.
The \emph{+ c\_r} comes from the fact that $j\_r$ starts at $c\_r$, contrarily to the left side.

Regarding the \hyperref[fig:ivsr-verif-res]{proof} duration, CVC5 was able to discharge all VCs automatically in 0.3 seconds.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for induc\_var\_strength\_red}  & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\hline 
\end{tabular}
\caption{Induction variable strength reduction (OCaml) verification results.}
\label{fig:ivsr-verif-res}
\end{center}
\end{table}


\FloatBarrier
\subsection{Loop alignment}
\label{subsec:rwc-la}

The second case study is about another compiler optimization known as the loop alignment.
Contrarily to the previous example, this one is not exactly a proof that the programs' output are the same for the same input.
In this case, we prove that, after the execution, a part of the memory of both programs is equal.
Recall the source, optimized and product \hyperref[fig:loop_alignment]{programs}, presented earlier.

\begin{figure}
\begin{minipage}{\linewidth}
\begin{biplangenv}


let loop_alignment_biplang (|_ n : int _|, |_ a : int array _|,
  |_ b : int array _|, |_ d : int array _|) = begin

  let i = |_ ref 1 _| in
  assert (!i_l <= n_l);
  b_l.(!i_l) <- a_l.(!i_l);
  d_l.(!i_l) <- b_l.(!i_l - 1);
  i_l := !i_l + 1;
  d_r.(1) <- b_r.(0);

  while !i < n <|> !i < n - 1 do
    (*@ variant   n_l - !i_l
        invariant !i_r >= 0 && !i_l = !i_r + 1
        invariant b_l.(!i_r) = a_l.(!i_r)
        invariant b_l.(!i_r - 1) = b_r.(!i_r - 1) 
        invariant forall k. 1 <= k < !i_l -> d_l.(k) = d_r.(k) *) 

    |_ b.(!i) <- a.(!i) _|;
    d.(!i) <- b.(!i - 1) <|> d.(!i + 1) <- b.(!i);
    i := |_ !i + 1 _|
  done;

  b_r.(n_r) <- a_r.(n_r)
end
(*@ requires n_l >= 1 && n_l = n_r 
    requires Array.length a_l = n_l + 1 
    requires Array.length b_l = n_l + 1 
    requires Array.length d_l = n_l + 1 

    requires Array.length a_l = Array.length a_r
    requires Array.length b_l = Array.length b_r
    requires Array.length d_l = Array.length d_r

    requires forall k. 0 <= k < n_l -> a_l.(k) = a_r.(k)
    requires b_l.(0) = b_r.(0)
		
    ensures  forall k. 1 <= k < n_l -> d_l.(k) = d_r.(k) *)
\end{biplangenv}
\end{minipage}
\caption{Loop alignment (BipLang).}
\label{fig:la_biplang}
\end{figure}


\begin{figure}
\begin{minipage}{\linewidth}
\begin{gospel}

  
let loop_alignment_ocaml (n_l : int) (n_r : int)
  (a_l : int array) (a_r : int array) (b_l : int array)
  (b_r : int array) (d_l : int array) (d_r : int array) =

  let i_l = ref (1) in
  let i_r = ref (1) in
  assert ((!i_l <= n_l));
  b_l.(!i_l) <- a_l.(!i_l);
  d_l.(!i_l) <- b_l.((!i_l - 1));
  i_l := (!i_l + 1);
  d_r.(1) <- b_r.(0);

  while (!i_l < n_l) do
    (*@ invariant (!i_l < n_l) <-> (!i_r < n_r - 1)
        variant   n_l - !i_l
        invariant !i_r >= 0 && !i_l = !i_r + 1
        invariant b_l.(!i_r) = a_l.(!i_r)
        invariant b_l.(!i_r - 1) = b_r.(!i_r - 1) 
        invariant forall k. 1 <= k < !i_l -> d_l.(k) = d_r.(k) *)    
    b_l.(!i_l) <- a_l.(!i_l);    
    b_r.(!i_r) <- a_r.(!i_r);    
    d_l.(!i_l) <- b_l.((!i_l - 1));    
    d_r.((!i_r + 1)) <- b_r.(!i_r);
    i_l := (!i_l + 1);
    i_r := (!i_r + 1)
  done;

  b_r.(n_r) <- a_r.(n_r)
(*@ requires n_l >= 1 && n_l = n_r 
    requires Array.length a_l = n_l + 1 
    requires Array.length b_l = n_l + 1 
    requires Array.length d_l = n_l + 1 

    requires Array.length a_l = Array.length a_r
    requires Array.length b_l = Array.length b_r
    requires Array.length d_l = Array.length d_r

    requires forall k. 0 <= k < n_l -> a_l.(k) = a_r.(k)
    requires b_l.(0) = b_r.(0)

    ensures  forall k. 1 <= k < n_l -> d_l.(k) = d_r.(k) *)
\end{gospel}
\end{minipage}
\caption{Loop alignment (OCaml).}
\label{fig:la_ocaml}
\end{figure}

This biprogram and product program are slightly different from the product program presented before, but the proof was inspired by the one its authors developed; that one is available \href{https://software.imdea.org/~ckunz/rellog/rellog-examples.tgz}{here}.
We renamed the $j$ and renamed it to $i\_r$, since it represents the same as $i\_l$.

Regarding the pre-conditions, we require \emph{n\_l} to be equal or greater than 1 and both sides' $n$ value should match too.
There are restrictions on the the arrays' lengths, which should all be equal, between left and right side and also equal to \emph{n\_l + 1}.
Furthermore, the elements of both sides' $a$ array should be in agreement, one by one; however, this requirement does not apply to the last element.
The last pre-condition simply requires that the value of the first element of both $b$'s to be the same.
Finally, the post-condition establishes that both programs' memory finish in a state where the values of the elements of the $d$ array match, excluding the first and last elements from this guarantee.

The program starts with an initial assignment and the unroll of the first loop iteration so we can reason about both programs in tandem during the cycle.
Since the conditions of the loop are not exactly the same for both sides, we take advantage of \hyperref[fig:translation-biprograms-rules]{rule 7} through a pipe, which generates the first invariant automatically: \emph{invariant (!i\_l < n\_l) $\leftrightarrow$ (!i\_r < n\_r - 1)}.
Inside the while, there are three assignments, two that are exactly the same for both sides and one that differs and represents precisely the optimization.
Finally, since the right side program is one iteration behind its left counterpart, we make one last assignment after the loop: \emph{b\_r.(n\_r) $\leftarrow$ a\_r.(n\_r)}.

Regarding the specification of the loop, we have a trivial variant that proves termination and 4 invariants.
The first one, \emph{invariant !i\_r $\geq$ 0 \&\& !i\_l = !i\_r + 1}, states that both $i$'s are never negative and that the right side is always one iteration behind the left side, as we mentioned before.
The second invariant, \emph{b\_l.(!i\_r) = a\_l.(!i\_r)}, could be rewritten as \emph{b\_l.(!i\_l + 1) = a\_l.(!i\_l + 1)} and simply states what happens in the first assignment of the cycle.
Next, \emph{invariant b\_l.(!i\_r - 1) = b\_r.(!i\_r - 1)} establishes that the last iteration assigned to both sides of the $b$ array the same value, as we can see from the two first loop assignments and the pre-condition regarding the values of the elements of $a$.
Finally, the invariant \emph{$\forall$ k. 1 $\leq$ k < !i\_l $\rightarrow$ d\_l.(k) = d\_r.(k)} means that every position of the $d$ array, on both sides, has the same value, starting at index 1 and going to the previous' iteration $i$.

The proof did not require any human interaction since CVC5 discharged all VCs in approximately 1.82 seconds.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{CVC5 1.0.6} \\ 
\hline
\explanation{VC for loop\_alignment\_biplang}  & \explanation{assertion} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.09} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.10} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.06} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop variant decrease} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.04} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.13} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.33} \\ 
\cline{2-3}
 & \explanation{index in array bounds} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.05} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.04} \\ 
\hline 
\end{tabular}
\caption{Loop alignment (OCaml) verification results.}
\end{center}
\end{table}


\FloatBarrier
\subsection{Conditionally aligned loops}
\label{subsec:rwc-cal}

The third and last real world example is also not a proof of equivalence, but for a different reason.
Instead, it is a proof that the left program's output is always larger than the right side program's output, assuming agreement of inputs and some other preconditions.
\hyperref[fig:cond_align_loops_ex]{Recall} the unary programs, that compute the factorial and the exponent of \emph{x >= 4} and their biprogram.
The \emph{cond\_align\_loops\_biplang} program below is the same as WhyRel's biprogram, but rewritten in BipLang.

Our proof was inspired by the \href{https://github.com/dnaumann/RelRL/blob/main/examples/majorization}{one} developed by WhyRel's authors.
Ours excludes the specification related to pointer-based programs, since that is not our target.
However, we include the $mult$ axiom, which we found indispensable for the proof to finish without manually invoking tactics.
Both our and WhyRel's proofs are partial, since we do not prove termination (as indicated by the \emph{diverges} keyword).
So, with no required human intervention, the proof was done by Z3 in approximately 0.32 seconds.

Now, if you look carefully at the translated program, \emph{cond\_align\_loops\_ocaml}, you may notice that there is dead code.
Concretely, these \emph{z\_l := (!z\_l * !y\_l); y\_l := (!y\_l - 1)} and these \emph{z\_r := (!z\_r * 2); y\_r := (!y\_r - 1)} branches.
That code is unreachable since the loop condition and alignment guard, on the left side, get translated to \emph{(!y\_l > 4) \&\& ((!w\_l mod n\_l) <> 0)}, and immediately after that we have an \emph{if...then...else} block, in which the condition is contraditory \emph{(!w\_l mod n\_l) = 0}.
The same logic happens for the right side program.
That is also the reason why the \emph{invariant !y\_l = !y\_r} can be proven, since the only branch that updates these variables is the one that updates them at the same time (and with the same value).
Nevertheless, this is simply a quirk of this specific example, that happens because the condition of the \emph{if...then...else} block inside the while loop was defined as contraditory to the alignment guard by the authors of the program.
Therefore, looking again at \hyperref[fig:trans-ex-third]{this} other example of a conditionally aligned loop, you can see that there are no contraditory conditions that create cases of unreachable code.

\begin{center}
\begin{biplangenv}


(*@ axiom mult: forall a:int, b:int, c:int, d:int.
   0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b -> c > d -> 
     (a * c) > (b * d) *)

let cond_align_loops_biplang (|_x : int_|, |_n : int_|) : |_int_| = begin
  let y = |_ ref x _| in
  let z = ref 24 <|> ref 16 in 
  let w = |_ ref 0 _| in

  while !y > 4 <|> !y > 4 . (!w mod n <> 0) <|> (!w mod n <> 0) do
    (*@ invariant !y_l = !y_r && !y_l >= 4
        invariant !z_r > 0 && !z_l > !z_r *)

    if (((!w mod n) = 0) <|> ((!w mod n) = 0)) then begin
      z := (!z * !y <|> !z * 2);
      y := |_ !y - 1 _|
    end else begin () end;

    w := |_ !w + 1 _|
  done; 

  |_ !z _|
end
(*@ requires x_l = x_r && x_l >= 4 && n_l = n_r && n_l > 0
    diverges
    ensures  match result with (l_res, r_res) -> l_res > r_res *)
\end{biplangenv}
\phantomsection
\captionof{figure}{Conditionally aligned loops (BipLang).}\label{fig:cond_aligned_biplang}
\end{center}

\begin{center}
\begin{gospel}


(*@ axiom mult: forall a:int, b:int, c:int, d:int.
   0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b -> c > d -> 
     (a * c) > (b * d) *)

let cond_align_loops_ocaml (x_l : int) (x_r : int) 
  (n_l : int) (n_r : int) : int * int =

  let y_l = ref (x_l) in
  let y_r = ref (x_r) in
  let z_l = ref (24) in
  let z_r = ref (16) in
  let w_l = ref (0) in
  let w_r = ref (0) in

  while ((!y_l > 4) || (!y_r > 4)) do
    (*@ invariant !y_l = !y_r && !y_l >= 4
        invariant !z_r > 0 && !z_l > !z_r 
        invariant (!y_l > 4 && mod !w_l n_l <> 0) ||
                  (!y_r > 4 && mod !w_r n_r <> 0) ||
                  (not (!y_l > 4) && not (!y_r > 4)) ||
                  (!y_l > 4 && !y_r > 4) *)

    if ((!y_l > 4) && ((!w_l mod n_l) <> 0))
    then begin 
      if ((!w_l mod n_l) = 0)
      then begin 
        z_l := (!z_l * !y_l);
        y_l := (!y_l - 1)
      end else begin 
        ()
      end;
      w_l := (!w_l + 1)
    end else begin 
      if ((!y_r > 4) && ((!w_r mod n_r) <> 0))
      then begin 
        if ((!w_r mod n_r) = 0)
        then begin 
          z_r := (!z_r * 2);
          y_r := (!y_r - 1)
        end else begin 
          ()
        end;
        w_r := (!w_r + 1)
      end else begin 
        assert ( (((!w_l mod n_l) = 0)) = (((!w_r mod n_r) = 0)) );
        if ((!w_l mod n_l) = 0)
        then begin 
          z_l := (!z_l * !y_l);
          z_r := (!z_r * 2);
          y_l := (!y_l - 1);
          y_r := (!y_r - 1)
        end else begin 
          ()
        end;
        w_l := (!w_l + 1);
        w_r := (!w_r + 1)
      end
    end
  done;

  (!z_l, !z_r)
(*@ requires x_l = x_r && x_l >= 4 && n_l = n_r && n_l > 0
    diverges
    ensures  match result with (l_res, r_res) -> l_res > r_res *)
\end{gospel}
\phantomsection
\captionof{figure}{Conditionally aligned loops (OCaml).}\label{fig:cond_aligned_ocaml}
\end{center}


\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
\hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.14.1} \\ 
\hline
\explanation{VC for cal\_ml}  & \explanation{loop invariant init} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{loop invariant init} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{assertion} & \valid{0.03} \\ 
\cline{2-3}
 & \explanation{precondition} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.02} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.00} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{loop invariant preservation} & \valid{0.01} \\ 
\cline{2-3}
 & \explanation{postcondition} & \valid{0.00} \\ 
\hline 
\end{tabular}
\caption{Conditionally aligned loops (OCaml) verification results.}
\end{center}
\end{table}

