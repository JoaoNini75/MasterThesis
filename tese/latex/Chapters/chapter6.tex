%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter6.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter6.tex}%

\chapter{Conclusion and Future Work}
\label{cha:conclusion}

This thesis took the deep research done in the area of program equivalence, relational verification and product programs in order to produce a tool that helps programmers proof that two different programs are equivalent, among other relational properties.
We created a language that can be seen simultaneously as a subset and a superset of OCaml, since it adds some symbols and constructions but does not have all of the features of OCaml.
This happened because the focus of this work does not include pointer based programs, but all of the components of bip2ml were constructed with ease of extensability in mind. 
Therefore, if we come to realize that it makes sense, the necessary features could be added with relative ease.
The similarities to OCaml are important since it means that programmers that are comfortable with that language will have an easier adaptation period when writing code in BipLang.

One of the main goals of our work was to bring the translation rules of WhyRel into the world of OCaml.
This was possible due to the tight integration with GOSPEL and Cameleer.
It enabled the reasoning about relational verification, through all of the bip2ml and Cameleer pipeline, to reach the powerful Why3. 
The case studies that we presented reveal that we were able to apply those rules correctly and use our tool to verify real world examples of program equivalence.
Not only program equivalence, but also other relational properties such as majorization (therefore minorization as well) and the equality of the programs' memories after the execution finishes.
In the future, this tool could very likely be used to reason about other relational properties.
It would be a matter of putting bip2ml to the test with more interesting and complex examples.

Although we are able introduce some invariants automatically (thanks to the WhyRel rules), there is still a long way to go when we discuss the automation of the proof of program equivalence.
We wonder if we could infer trivial variants and some other invariants, adding then those to specification attached to the final generated code.
That would be a way of reducing weight off the shoulders of the users of bip2ml.










