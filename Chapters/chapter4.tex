%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Preliminary Results}
\label{cha:preliminary_results}

Proving the equivalence of two different OCaml programs can be a hard task, depending on the complexity and size of said programs.
Therefore, we implemented a small set of simple programs that show two different ways of establishing program equivalence.
The first one relies on including a post-condition that states that the result of program P$_1$ is equal to the result of program P$_2$ for the same input.
The second way uses product programs, where we present the source and the transformed programs.
Then, we apply \hyperref[fig:product_construction_reduction]{these} rules to create the corresponding product program, which can be proven with standard verification.


\section{Simple equivalence proofs}
\label{sec:results_eq_proofs}

In this section, we present the functional and imperative implementations of each algorithm.
We also compare the specification of each implementation, pointing the similarities and differences.
All of the following programs have been verified using \hyperref[sec:cameleer]{Cameleer} and the information in the tables was provided by \hyperref[sec:why3]{Why3}.


\subsection{Factorial}
\label{sub:factorial}

Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
They differ, however, in the post condition, which is \emph{result = fact n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has an invariant, \emph{!res = fact (i-1)}. 

\bigskip
\newcommand{\provername}[1]{\cellcolor{yellow!25}
\begin{sideways}\textbf{#1}~~\end{sideways}}
\newcommand{\explanation}[1]{\cellcolor{yellow!13}lemma \texttt{#1}}
\newcommand{\transformation}[1]{\cellcolor{yellow!13}transformation \texttt{#1}}
\newcommand{\subgoal}[2]{\cellcolor{yellow!13}subgoal #2}
\newcommand{\valid}[1]{\cellcolor{green!13}#1}
\newcommand{\unknown}[1]{\cellcolor{red!20}#1}
\newcommand{\invalid}[1]{\cellcolor{red!50}#1}
\newcommand{\timeout}[1]{\cellcolor{red!20}(#1)}
\newcommand{\outofmemory}[1]{\cellcolor{red!20}(#1)}
\newcommand{\noresult}{\multicolumn{1}{>{\columncolor[gray]{0.8}}c|}{~}}
%\newcommand{\failure}{\cellcolor{red!20}failure}
\newcommand{\highfailure}{\cellcolor{red!50}FAILURE}
    
\begin{minipage}{\linewidth}
\begin{gospel}
  (*@ function rec fact (n: integer) : integer =
  if n = 0 then 1 else n * fact (n-1) *)
  (*@ requires n >= 0 
    variant n *)
\end{gospel}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{ocamlenv}
  let fact_iter (n: int) : int =
    if n <= 1 then 1
    else
      begin 
        let res = ref 1 in
        for i = 2 to n do
          (*@ invariant !res = fact (i-1) *)
          res := !res * i
        done;
        !res
      end
  (*@ result = fact_iter n
    requires n >= 0 
    ensures result = fact n *)
\end{ocamlenv}
\end{minipage}

Regarding the proof of both the implementations above, Z3 (through Cameleer) was able to discard all of the verification conditions (VCs) automatically.
Furthermore, this SMT solver took a quarter of a second to complete the whole proof, verifying the functional implementation in 0.08 seconds and the imperative implementation in 0.17 seconds.

\begin{table}[!h]
\begin{center}
\begin{tabular}{|l|l|l|l|c|}
  \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
  \hline
  \explanation{VC for fact}  & \explanation{variant decrease} & \valid{0.03} \\ 
  \cline{2-3}
    & \explanation{precondition} & \valid{0.05} \\ 
  \hline
  \explanation{VC for fact\_iter}  & \explanation{postcondition} & \valid{0.04} \\ 
  \cline{2-3}
    & \explanation{loop invariant init} & \valid{0.05} \\ 
  \cline{2-3}
    & \explanation{loop invariant preservation} & \valid{0.04} \\ 
  \cline{2-3}
    & \explanation{postcondition} & \valid{0.01} \\ 
  \cline{2-3}
    & \explanation{VC for fact\_iter} & \valid{0.03} \\ 
  \hline 
\end{tabular}
\caption{Factorial implementations verification results.}
\end{center}
\end{table}


\subsection{Fibonacci}
\label{sub:fibonacci}

Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
They differ, however, in the post condition, which is \emph{result = fib n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has two invariants, \emph{!prev = fib (i-2)} and \emph{!res = fib (i-1)}. 

\begin{minipage}{\linewidth}
\begin{gospel}
  (*@ function rec fib (n: integer) : integer =
  if n <= 1 then n else fib (n-1) + fib (n-2) *)
  (*@ requires n >= 0 
    variant n *)
\end{gospel}
\end{minipage}

\bigskip

\begin{minipage}{\linewidth}
\begin{ocamlenv}
  let fib_iter (n: int) : int =
    if n <= 1 then n
    else
      begin
        let prev = ref 0 in 
        let res = ref 1 in
        let temp = ref 1 in

        for i = 2 to n do
          (*@ invariant !prev = fib (i-2)
            invariant !res = fib (i-1) *)
          temp := !res;
          res := !res + !prev;
          prev := !temp;
        done;

        !res
      end
  (*@ result = fib_iter n
    requires n >= 0 
    ensures result = fib n *)
\end{ocamlenv}
\end{minipage}

\bigskip

Using Cameleer and Z3 as we did with the factorial, we were able to prove the correctness of both implementations without any human intervention, taking a total of 0.3 seconds.
Besides that, the SMT solver spent 0.13 seconds verifying the functional implementation and 0.17 seconds verifying the imperative implementation.

\begin{table}[!h]
  \begin{center}
  \begin{tabular}{|l|l|l|l|c|}
    \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
    \hline
    \explanation{VC for fib}  & \explanation{variant decrease} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{precondition} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{variant decrease} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{precondition} & \valid{0.04} \\ 
    \hline
    \explanation{VC for fib\_iter}  & \explanation{postcondition} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{loop invariant init} & \valid{0.02} \\ 
    \cline{2-3}
      & \explanation{loop invariant init} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{loop invariant preservation} & \valid{0.02} \\ 
    \cline{2-3}
      & \explanation{loop invariant preservation} & \valid{0.03} \\ 
    \cline{2-3}
      & \explanation{postcondition} & \valid{0.01} \\ 
    \cline{2-3}
      & \explanation{VC for fib\_iter} & \valid{0.03} \\ 
    \hline 
  \end{tabular}
  \caption{Fibonacci implementations verification results.}
\end{center}
\end{table}


\section{Equivalence proofs using product programs}
\label{sec:results_eq_proofs_pp}

In this section, we present a program and a slightly different version and then combine them using the technique of product programs. 
Finally, we verified those product programs using the \hyperref[sec:why3]{Why3} tool.
The results present on the tables was also generated by that software.


\subsection{Program based on assignments}
\label{sub:results_assignments}


\subsection{Program with a while loop}
\label{sub:results_while}

