%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Preliminary Results}
\label{cha:porting_novathesis}

Proving the equivalence of two different OCaml programs can be a hard task, depending on the complexity and size of said programs.
Therefore, we started with two of the most basic examples, as a way to show that this approach makes sense and, most importantly, is possible.

\section{Proof Examples}
\label{sec:results_examples}

  In this section, we present the functional and imperative implementations of each algorithm. We also compare the specification of each implementation, pointing the similarities and differences. All of the following programs have been verified using Cameleer.

  \subsection{Factorial}
  \label{sub:factorial}

  \begin{lstlisting}[language=caml, caption={Functional factorial implementation},captionpos=b]
    (*@ function rec fact (n: integer) : integer =
    if n = 0 then 1 else n * fact (n-1) *)
    (*@ requires n >= 0 
      variant n *)
  \end{lstlisting}


  \begin{lstlisting}[language=caml, caption={Imperative factorial implementation},captionpos=b]
    let fact_iter (n: int) : int =
      if n <= 1 then 1
      else
        begin 
          let res = ref 1 in
          for i = 2 to n do
            (*@ invariant !res = fact (i-1) *)
            res := !res * i
          done;
          !res
        end
    (*@ result = fact_iter n
      requires n >= 0 
      ensures result = fact n *)
  \end{lstlisting}

  \subsection{Fibonacci}
  \label{sub:fibonacci}

  \begin{lstlisting}[language=caml, caption={Functional fibonacci implementation},captionpos=b]
    (*@ function rec fib (n: integer) : integer =
	  if n <= 1 then n else fib (n-1) + fib (n-2) *)
	  (*@ requires n >= 0 
		  variant n *)
  \end{lstlisting}


  \begin{lstlisting}[language=caml, caption={Imperative fibonacci implementation},captionpos=b]
    let fib_iter (n: int) : int =
      if n <= 1 then n
      else
        begin
          let prev = ref 0 in 
          let res = ref 1 in
          let temp = ref 1 in

          for i = 2 to n do
            (*@ invariant !prev = fib (i-2)
              invariant !res = fib (i-1) *)
            temp := !res;
            res := !res + !prev;
            prev := !temp;
          done;

          !res
        end
    (*@ result = fib_iter n
      requires n >= 0 
      ensures result = fib n *)
  \end{lstlisting}
