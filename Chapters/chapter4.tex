%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{Preliminary Results}
\label{cha:porting_novathesis}

Proving the equivalence of two different OCaml programs can be a hard task, depending on the complexity and size of said programs.
Therefore, we started with two of the most basic examples, as a way to show that this approach makes sense and, most importantly, is possible.

\section{Proof Examples}
\label{sec:results_examples}

  In this section, we present the functional and imperative implementations of each algorithm. We also compare the specification of each implementation, pointing the similarities and differences. All of the following programs have been verified using Cameleer.

  \subsection{Factorial}
  \label{sub:factorial}

  Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
  They differ, however, in the post condition, which is \emph{result = fact n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
  Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has an invariant, \emph{!res = fact (i-1)}. 

  \bigskip
  \newcommand{\provername}[1]{\cellcolor{yellow!25}
  \begin{sideways}\textbf{#1}~~\end{sideways}}
  \newcommand{\explanation}[1]{\cellcolor{yellow!13}lemma \texttt{#1}}
  \newcommand{\transformation}[1]{\cellcolor{yellow!13}transformation \texttt{#1}}
  \newcommand{\subgoal}[2]{\cellcolor{yellow!13}subgoal #2}
  \newcommand{\valid}[1]{\cellcolor{green!13}#1}
  \newcommand{\unknown}[1]{\cellcolor{red!20}#1}
  \newcommand{\invalid}[1]{\cellcolor{red!50}#1}
  \newcommand{\timeout}[1]{\cellcolor{red!20}(#1)}
  \newcommand{\outofmemory}[1]{\cellcolor{red!20}(#1)}
  \newcommand{\noresult}{\multicolumn{1}{>{\columncolor[gray]{0.8}}c|}{~}}
  %\newcommand{\failure}{\cellcolor{red!20}failure}
  \newcommand{\highfailure}{\cellcolor{red!50}FAILURE}
      
  \begin{gospel}
    (*@ function rec fact (n: integer) : integer =
    if n = 0 then 1 else n * fact (n-1) *)
    (*@ requires n >= 0 
      variant n *)
  \end{gospel}


  \begin{lstlisting}[language=caml, caption={Imperative factorial implementation},captionpos=b]
    let fact_iter (n: int) : int =
      if n <= 1 then 1
      else
        begin 
          let res = ref 1 in
          for i = 2 to n do
            (*@ invariant !res = fact (i-1) *)
            res := !res * i
          done;
          !res
        end
    (*@ result = fact_iter n
      requires n >= 0 
      ensures result = fact n *)
  \end{lstlisting}

  Write about the table below!!!

  \begin{table}[!h]
  \begin{center}
  \begin{tabular}{|l|l|l|l|c|}
    \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
    \hline
    \explanation{VC for fact}  & \explanation{variant decrease} & \valid{0.03} \\ 
    \cline{2-3}
     & \explanation{precondition} & \valid{0.05} \\ 
    \hline
    \explanation{VC for fact\_iter}  & \explanation{postcondition} & \valid{0.04} \\ 
    \cline{2-3}
     & \explanation{loop invariant init} & \valid{0.05} \\ 
    \cline{2-3}
     & \explanation{loop invariant preservation} & \valid{0.04} \\ 
    \cline{2-3}
     & \explanation{postcondition} & \valid{0.01} \\ 
    \cline{2-3}
     & \explanation{VC for fact\_iter} & \valid{0.03} \\ 
    \hline 
  \end{tabular}
  \caption{Factorial implementations verification results.}
  \end{center}
  \end{table}


  \subsection{Fibonacci}
  \label{sub:fibonacci}

  Both functional and imperative implementations of the factorial have only one pre condition \emph{n >= 0}.
  They differ, however, in the post condition, which is \emph{result = fib n} in the case of the imperative implementation and non-existent in the case of the functional implementation.
  Moreover, the functional implementation has a variant \emph{n}, while the imperative implementation has two invariants, \emph{!prev = fib (i-2)} and \emph{!res = fib (i-1)}. 

  \begin{lstlisting}[language=caml, caption={Functional fibonacci implementation},captionpos=b]
    (*@ function rec fib (n: integer) : integer =
	  if n <= 1 then n else fib (n-1) + fib (n-2) *)
	  (*@ requires n >= 0 
		  variant n *)
  \end{lstlisting}


  \begin{lstlisting}[language=caml, caption={Imperative fibonacci implementation},captionpos=b]
    let fib_iter (n: int) : int =
      if n <= 1 then n
      else
        begin
          let prev = ref 0 in 
          let res = ref 1 in
          let temp = ref 1 in

          for i = 2 to n do
            (*@ invariant !prev = fib (i-2)
              invariant !res = fib (i-1) *)
            temp := !res;
            res := !res + !prev;
            prev := !temp;
          done;

          !res
        end
    (*@ result = fib_iter n
      requires n >= 0 
      ensures result = fib n *)
  \end{lstlisting}

  Write about the table below!!!

  \begin{table}[!h]
    \begin{center}
    \begin{tabular}{|l|l|l|l|c|}
      \hline \multicolumn{2}{|c|}{Proof obligations } & \provername{Z3 4.13.0} \\ 
      \hline
      \explanation{VC for fib}  & \explanation{variant decrease} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{precondition} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{variant decrease} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{precondition} & \valid{0.04} \\ 
      \hline
      \explanation{VC for fib\_iter}  & \explanation{postcondition} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{loop invariant init} & \valid{0.02} \\ 
      \cline{2-3}
       & \explanation{loop invariant init} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{loop invariant preservation} & \valid{0.02} \\ 
      \cline{2-3}
       & \explanation{loop invariant preservation} & \valid{0.03} \\ 
      \cline{2-3}
       & \explanation{postcondition} & \valid{0.01} \\ 
      \cline{2-3}
       & \explanation{VC for fib\_iter} & \valid{0.03} \\ 
      \hline 
    \end{tabular}
    \caption{Fibonacci implementations verification results.}
    \end{center}
    \end{table}
