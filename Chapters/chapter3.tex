%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\makeatletter
\newcommand{\ntifpkgloaded}{%
  \@ifpackageloaded%
}
\makeatother


\chapter{State of the Art}
\label{cha:state_of_the_art}



\section{Self-composition} 
\label{sec:self_composition}




\section{Cross-products} 
\label{sec:cross_products}




\section{Product Programs} 
\label{sec:product_programs}

\subsection{Motivation} 
\label{subsec:product_programs_motivation}

Relational Hoare Logic serves as a good starting point to compare the behaviour of two different executions of the same program or even two different programs.
However, there are few available tools and practical reasoning logics for relational verification.
One of the main limitations of the existing ones~\cite{DBLP:conf/popl/Benton04, DBLP:journals/tcs/Yang07} is the constraint of \emph{structural equivalence}.
Inversely, traditional program verification has diverse and extense tool support.
Therefore, as a way of getting around that obstacle, relational verification tasks could be soundly reduced into standard verification.
This means we would translate Hoare quadruples (\{$\Phi$\} \emph{P1} \emph{\textasciitilde} \emph{P2} \{$\Psi$\}) into Hoare triples (\{$\phi$\} \emph{P} \{$\psi$\}), making the triples valid when the quadruples are also valid.
Considering $\vDash$ the symbol for validity, the objective is finding \emph{$\phi$, P, $\psi$} that:
\[ \vDash \{\phi\} \, \textbf{P} \, \{\psi\} \ \ \ \rightarrow \ \ \ \ \ \vDash \{\Phi\} \, \textbf{P1} \sim \textbf{P2} \, \{\Psi\} \]

Let us consider two imperative and \emph{separable} programs \emph{P1} and \emph{P2}.
This enables the capacity of the assertions to be seen as first-order formulas about the variables of \emph{P1} and \emph{P2}.
Self-composition~\cite{DBLP:conf/csfw/BartheDR04} comes from the establishment of the wanted equalities above: \emph{P $\equiv$ P1;P2}, \emph{$\phi$ $\equiv$ $\Phi$} and \emph{$\psi$ $\equiv$ $\Psi$}.
This \hyperref[sec:self_composition]{already mentioned} construction is impractical~\cite{DBLP:conf/sas/TerauchiA05}, despite being sound and considerably complete.

There is another relevant method discussed in this \hyperref[sec:cross_products]{section}, the cross-products.
These suffer from the constraint of structural equivalence, making impossible to reason about properties or program optimizations that are based on different control flows.

Product Programs~\cite{DBLP:conf/fm/BartheCK11} appear to be the best path to follow, since they represent a general notion that combines the flexibility of self-composition in executing asynchronous steps and the efficiency of cross-products when it comes to treat synchronous steps. 


\subsection{From relational verification to standard verification} 
\label{subsec:product_programs_relverif_to_stdverif}

(pag 3-8)

Consider two generic programs \emph{P1} and \emph{P2} and their product program \emph{P}.
The approach of product programs to reduce relational reasoning into standard reasoning goes through the capacity of constructing \emph{P}, that simulates the execution of both \emph{P1} and \emph{P2}.
Next, we will describe the grammar rules to show how we will proceed and then explain how product programs are effectively constructed.

\subsubsection{Establishing the ground rules} 
\label{subsubsec:product_programs_ground_rules}

The commands in our programming model will stick to these grammar rules:
\[ \text{c ::=} \ \ \ \text{x:= e} \ | \ \text{a[e]:= e} \ | \ \textbf{skip} \ | \ \textbf{assert} \text{(b)} \ |
                    \ \text{c; c} \ | \ \textbf{if} \ \text{b} \ \textbf{then} \ \text{c1} \ \textbf{else} \ \text{c2} \ | \ \textbf{while} \ \text{b} \ \textbf{do} \ \text{c} \]

In this context, \emph{x} is a integer variable, \emph{a} is an array variable, \emph{e} is an integer expression and \emph{b} is a boolean expression.
Execution states are represented as \emph{S = (V$_i$ $\rightharpoonup$ $\mathbb{Z}$) X (V$_a$ $\rightharpoonup$ ($\mathbb{Z}$ $\rightharpoonup$ $\mathbb{Z}$)).}
The semantics of the commands are standard, deterministic and are based on the relation $\langle$c, $\sigma$$\rangle$ $\rightsquigarrow$ $\langle$c', $\sigma$'$\rangle$.
Notice that $\langle$\textbf{skip}, $\sigma$$\rangle$ marks the end of the programs, \textbf{assert}(b) blocks the execution of the program if \emph{b} is false and we let $\langle$c, $\sigma$$\rangle$ $\Downarrow$ $\sigma$' mean $\langle$c, $\sigma$$\rangle$ $\rightsquigarrow$* $\langle$\textbf{skip}, $\sigma$'$\rangle$.

As we discussed before in this document, two commands are \emph{separable} if they operate on disjoint sets of variables.
Similarly, we consider that two states are \emph{separable} if their domains are disjoint.
Consider $\mu$$_1$ $\uplus$ $\mu$$_2$ represent the union of finite maps:
\[
(\mu_1 \uplus \mu_2) \ x =
\begin{cases}
    \mu_1 x & \text{if } x \in \operatorname{dom}(\mu_1) \\
    \mu_2 x & \text{if } x \in \operatorname{dom}(\mu_2)
\end{cases}
\]

and overload this notation for the union of separable states ($\mu$,$\nu$) $\uplus$ ($\mu$',$\nu$'), whose definition is ($\mu$ $\uplus$ $\mu$', $\nu$ $\uplus$ $\nu$').
Taking into account that we assume that the states are separable, another way of looking at assertions is by viewing them as relations on states: ($\sigma$$_1$, $\sigma$$_2$) $\in$ $\llbracket$$\phi$$\rrbracket$ iff $\sigma$$_1$ $\uplus$ $\sigma$$_2$ $\in$ $\llbracket$$\phi$$\rrbracket$.
Therefore, the definition below illustrates the formal statement of valid relational specifications.
\bigskip

\textbf{Definition 1 -}  \emph{Two commands $c_1$ and $c_2$ satisfy the pre-condition $\phi$ and the post-condition $\psi$ described by a valid Hoare quadruple if,
                                for all states $\sigma$$_1$, $\sigma$$_2$, $\sigma$$_1$', $\sigma$$_2$' such that $\sigma_1$ $\uplus$ $\sigma_2$ $\in$ $\llbracket$$\phi$$\rrbracket$
                                and $\langle$$c_1$, $\sigma$$_1$$\rangle$ $\Downarrow$ $\sigma$$_1$' and $\langle$$c_2$, $\sigma$$_2$$\rangle$ $\Downarrow$ $\sigma$$_2$', we have $\sigma_1$' $\uplus$ $\sigma_2$' $\in$ $\llbracket$$\psi$$\rrbracket$.}

\bigskip
Since our objective is to reduce the validity of Hoare quadruples to validity of Hoare triples, we must say that we establish our notion of valid Hoare triple as stronger than usual.
It requires that the command allows the program to finish its execution, i.e., the command is \emph{non-stuck}.
\bigskip

\textbf{Definition 2 -}  \emph{A Hoare triple {$\phi$} c {$\psi$} is valid ($\vDash$ \{$\phi$\} c \{$\psi$\}) if c is $\phi$-nonstuck and for all $\sigma$, $\sigma$' $\in$ S, $\sigma$ $\in$ $\llbracket$$\phi$$\rrbracket$ and $\langle$c, $\sigma$$\rangle$ $\Downarrow$ $\sigma$' imply $\sigma$' $\in$ $\llbracket$$\psi$$\rrbracket$.}

\bigskip
This notion of validity requires, however, that we extend Hoare logic for it to be able to treat \textbf{assert} statements.
The necessary rule is:
\begin{figure}[h]
  \centering
  \begin{mathpar}
  
  \inferrule*[]
  { }
  {\vdash \ \{ \textit{b} \land \Phi \} \ \textbf{assert}\text{(b)} \ \{ \Phi \}}

  \end{mathpar}
\end{figure}


\subsubsection{Construction of Product Programs} 
\label{subsubsec:product_programs_construction}




\subsection{Examples} 
\label{subsec:product_programs_examples}

(pag 9-15)


\section{Program Equivalence}
\label{sec:program_equivalence}



