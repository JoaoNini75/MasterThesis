%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\makeatletter
\newcommand{\ntifpkgloaded}{%
  \@ifpackageloaded%
}
\makeatother


\chapter{State of the Art}
\label{cha:state_of_the_art}



\section{Self-composition} 
\label{sec:self_composition}




\section{Cross-products} 
\label{sec:cross_products}




\section{Product Programs} 
\label{sec:product_programs}

\subsection{Motivation} 
\label{subsec:product_programs_motivation}

Relational Hoare Logic serves as a good starting point to compare the behaviour of two different executions of the same program or even two different programs.
However, there are few available tools and practical reasoning logics for relational verification.
One of the main limitations of the existing ones~\cite{DBLP:conf/popl/Benton04, DBLP:journals/tcs/Yang07} is the constraint of \emph{structural equivalence}.
Inversely, traditional program verification has diverse and extense tool support.
Therefore, as a way of getting around that obstacle, relational verification tasks could be soundly reduced into standard verification.
This means we would translate Hoare quadruples (\{$\Phi$\} \emph{P1} \emph{\textasciitilde} \emph{P2} \{$\Psi$\}) into Hoare triples (\{$\phi$\} \emph{P} \{$\psi$\}), making the triples valid when the quadruples are also valid.
Considering $\vDash$ the symbol for validity, the objective is finding \emph{$\phi$, P, $\psi$} that:
\[ \vDash \{\phi\} \, \textbf{P} \, \{\psi\} \ \ \ \rightarrow \ \ \ \ \ \vDash \{\Phi\} \, \textbf{P1} \sim \textbf{P2} \, \{\Psi\} \]

Let us consider two imperative and \emph{separable} programs \emph{P1} and \emph{P2}.
This enables the capacity of the assertions to be seen as first-order formulas about the variables of \emph{P1} and \emph{P2}.
Self-composition~\cite{DBLP:conf/csfw/BartheDR04} comes from the establishment of the wanted equalities above: \emph{P $\equiv$ P1;P2}, \emph{$\phi$ $\equiv$ $\Phi$} and \emph{$\psi$ $\equiv$ $\Psi$}.
This \hyperref[sec:self_composition]{already mentioned} construction is impractical~\cite{DBLP:conf/sas/TerauchiA05}, despite being sound and considerably complete.

There is another relevant method discussed in this \hyperref[sec:cross_products]{section}, the cross-products.
These suffer from the constraint of structural equivalence, making impossible to reason about properties or program optimizations that are based on different control flows.

Product Programs~\cite{DBLP:conf/fm/BartheCK11} appear to be the best path to follow, since they represent a general notion that combines the flexibility of self-composition in executing asynchronous steps and the efficiency of cross-products when it comes to treat synchronous steps. 


\subsection{From relational verification to standard verification} 
\label{subsec:product_programs_relverif_to_stdverif}

Consider two generic programs \emph{P1} and \emph{P2} and their product program \emph{P}.
The approach of product programs to reduce relational reasoning into standard reasoning goes through the capacity of constructing \emph{P}, that simulates the execution of both \emph{P1} and \emph{P2}.
Next, we will describe the grammar rules to show how we will proceed and then explain how product programs are effectively constructed.

\subsubsection{Establishing the ground rules} 
\label{subsubsec:product_programs_ground_rules}

The commands in our programming model will stick to these grammar rules:
\[ \text{c ::=} \ \ \ \text{x:= e} \ | \ \text{a[e]:= e} \ | \ \textbf{skip} \ | \ \textbf{assert} \text{(b)} \ |
                    \ \text{c; c} \ | \ \textbf{if} \ \text{b} \ \textbf{then} \ \text{c1} \ \textbf{else} \ \text{c2} \ | \ \textbf{while} \ \text{b} \ \textbf{do} \ \text{c} \]

In this context, \emph{x} is a integer variable, \emph{a} is an array variable, \emph{e} is an integer expression and \emph{b} is a boolean expression.
Execution states are represented as \emph{S = (V$_i$ $\rightharpoonup$ $\mathbb{Z}$) X (V$_a$ $\rightharpoonup$ ($\mathbb{Z}$ $\rightharpoonup$ $\mathbb{Z}$)).}
The semantics of the commands are standard, deterministic and are based on the relation $\langle$c, $\sigma$$\rangle$ $\rightsquigarrow$ $\langle$c', $\sigma$'$\rangle$.
Notice that $\langle$\textbf{skip}, $\sigma$$\rangle$ marks the end of the programs, \textbf{assert}(b) blocks the execution of the program if \emph{b} is false and we let $\langle$c, $\sigma$$\rangle$ $\Downarrow$ $\sigma$' mean $\langle$c, $\sigma$$\rangle$ $\rightsquigarrow$* $\langle$\textbf{skip}, $\sigma$'$\rangle$.

As we discussed before in this document, two commands are \emph{separable} if they operate on disjoint sets of variables.
Similarly, we consider that two states are \emph{separable} if their domains are disjoint.
Consider $\mu$$_1$ $\uplus$ $\mu$$_2$ represent the union of finite maps:
\[
(\mu_1 \uplus \mu_2) \ x =
\begin{cases}
    \mu_1 x & \text{if } x \in \operatorname{dom}(\mu_1) \\
    \mu_2 x & \text{if } x \in \operatorname{dom}(\mu_2)
\end{cases}
\]

and overload this notation for the union of separable states ($\mu$,$\nu$) $\uplus$ ($\mu$',$\nu$'), whose definition is ($\mu$ $\uplus$ $\mu$', $\nu$ $\uplus$ $\nu$').
Taking into account that we assume that the states are separable, another way of looking at assertions is by viewing them as relations on states: ($\sigma$$_1$, $\sigma$$_2$) $\in$ $\llbracket$$\phi$$\rrbracket$ iff $\sigma$$_1$ $\uplus$ $\sigma$$_2$ $\in$ $\llbracket$$\phi$$\rrbracket$.
Therefore, the definition below illustrates the formal statement of valid relational specifications.
\bigskip

\textbf{Definition 1 -}  \emph{Two commands $c_1$ and $c_2$ satisfy the pre-condition $\phi$ and the post-condition $\psi$ described by a valid Hoare quadruple if,
                                for all states $\sigma$$_1$, $\sigma$$_2$, $\sigma$$_1$', $\sigma$$_2$' such that $\sigma_1$ $\uplus$ $\sigma_2$ $\in$ $\llbracket$$\phi$$\rrbracket$
                                and $\langle$$c_1$, $\sigma$$_1$$\rangle$ $\Downarrow$ $\sigma$$_1$' and $\langle$$c_2$, $\sigma$$_2$$\rangle$ $\Downarrow$ $\sigma$$_2$', we have $\sigma_1$' $\uplus$ $\sigma_2$' $\in$ $\llbracket$$\psi$$\rrbracket$.}

\bigskip
Since our objective is to reduce the validity of Hoare quadruples to validity of Hoare triples, we must say that we establish our notion of valid Hoare triple as stronger than usual.
It requires that the command allows the program to finish its execution, i.e., the command is \emph{non-stuck}.
\bigskip

\textbf{Definition 2 -}  \emph{A Hoare triple {$\phi$} c {$\psi$} is valid ($\vDash$ \{$\phi$\} c \{$\psi$\}) if c is $\phi$-nonstuck and for all $\sigma$, $\sigma$' $\in$ S, $\sigma$ $\in$ $\llbracket$$\phi$$\rrbracket$ and $\langle$c, $\sigma$$\rangle$ $\Downarrow$ $\sigma$' imply $\sigma$' $\in$ $\llbracket$$\psi$$\rrbracket$.}

\bigskip
This notion of validity requires, however, that we extend Hoare logic for it to be able to treat \textbf{assert} statements.
The necessary rule is:
\begin{figure}[h]
  \centering
  \begin{mathpar}
  
  \inferrule*[]
  { }
  {\vdash \ \{ \textit{b} \land \Phi \} \ \textbf{assert}\text{(b)} \ \{ \Phi \}}

  \end{mathpar}
\end{figure}


\subsubsection{Construction of Product Programs} 
\label{subsubsec:product_programs_construction}

Firstly in this section, we define the rules that will be used to deal with structurally equivalent programs. 
After that, we that set with structural transformations to allow the treatment of programs with different structures.

\begin{figure}[h]
  \centering
  \begin{mathpar}

  \inferrule*[]
    { }
    {c_1 \times c_2 \; \rightarrow \; c_1 ; c_2}

  \inferrule*[]
    {c_1 \times c_2 \; \rightarrow \; c \\ 
     c'_1 \times c'_2 \; \rightarrow \; c'}
    {(c_1 ; c'_1) \times (c_2 ; c'_2) \; \rightarrow \; c ; c'}

  \inferrule*[]
    {c_1 \times c_2 \; \rightarrow \; c}
    {(\textbf{while} \; b_1 \; \textbf{do} \; c_1) \times (\textbf{while} \; b_2 \; \textbf{do} \; c_2) \; \rightarrow \;
    \textbf{assert}(b_1 \Leftrightarrow b_2); \; \textbf{while} \; b_1 \; \textbf{do} \; (c ; \textbf{assert}(b_1 \Leftrightarrow b_2))}

  \inferrule*[]
    {c_1 \times c_2 \; \rightarrow \; c \\ 
    c'_1 \times c'_2 \; \rightarrow \; c'}
    {(\textbf{if} \; b_1 \; \textbf{then} \; c_1 \; \textbf{else} \; c'_1) \times (\textbf{if} \; b_2 \; \textbf{then} \; c_2 \; \textbf{else} \; c'_2) \; \rightarrow \;
    \textbf{assert}(b_1 \Leftrightarrow b_2); \; \textbf{if} \; b_1 \; \textbf{then} \; c \; \textbf{else} \; c'}

  \inferrule*[]
    {c_1 \times c \; \rightarrow \; c'_1 \\ 
    c_2 \times c \; \rightarrow \; c'_2}
    {(\textbf{if} \; b \; \textbf{then} \; c_1 \; \textbf{else} \; c_2) \times c \; \rightarrow \;
    \textbf{if} \; b \; \textbf{then} \; c'_1 \; \textbf{else} \; c'_2}  
    
  \end{mathpar}
  \caption{Product construction rules.}
\end{figure}

The figure above describes a set of rules to derive a product construction judgment of the type \emph{c$_1$ $\times$ c$_2$ $\rightarrow$ c.}
To make sure that \emph{c} simulates with precision the behaviour of \emph{c$_1$ and c$_2$}, the construction of products introduces \textbf{assert} statements.
During the phase of the verification of the program, these validation constraints are viewed as local assertions and discharged.
Let us consider the rule that synchronizes two loops, for example: \textbf{assert}(b$_1$ $\Leftrightarrow$ b$_2$) is necessary to guarantee that the number of iterations of each loop is the same.
This achieves what we aimed for, that is, the product program can be verified with standard logic.
\bigskip

\textbf{Proposition 1 -}  \emph{For all statements $c_1$ and $c_2$ and pre-conditions $\phi$ and post-conditions $\psi$, if $c_1$ $\times$ $c_2$ $\rightarrow$ c and $\vDash$ {$\phi$} c {$\psi$} then $\vDash$ {$\phi$} $c_1$ \textasciitilde $c_2$ {$\psi$}.}

\bigskip
In other words, if \emph{c} is the resulting product program of \emph{c1} and \emph{c2}, then we can reason about the validity of the relational judgment between \emph{c1} and \emph{c2} through the validity of the standard judgment of \emph{c}.



\subsection{Examples} 
\label{subsec:product_programs_examples}

%(pag 9-15)


\section{Program Equivalence}
\label{sec:program_equivalence}



