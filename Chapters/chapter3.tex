%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter3.tex
%% NOVA thesis document file
%%
%% Chapter with a short latex tutorial and examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\makeatletter
\newcommand{\ntifpkgloaded}{%
  \@ifpackageloaded%
}
\makeatother


\chapter{State of the Art}
\label{cha:state_of_the_art}



\section{Self-composition} 
\label{sec:self_composition}




\section{Cross-products} 
\label{sec:cross_products}




\section{Product Programs} 
\label{sec:product_programs}

\subsection{Motivation} 
\label{sec:product_programs_motivation}

Relational Hoare Logic serves as a good starting point to compare the behaviour of two different executions of the same program or even two different programs.
However, there are few available tools and practical reasoning logics for relational verification.
One of the main limitations of the existing ones~\cite{DBLP:conf/popl/Benton04, DBLP:journals/tcs/Yang07} is the constraint of \emph{structural equivalence}.
Inversely, traditional program verification has diverse and extense tool support.
Therefore, as a way of getting around that obstacle, relational verification tasks could be soundly reduced into standard verification.
This means we would translate Hoare quadruples (\{$\Phi$\} \emph{P1} \emph{\textasciitilde} \emph{P2} \{$\Psi$\}) into Hoare triples (\{$\phi$\} \emph{P} \{$\psi$\}), making the triples valid when the quadruples are also valid.
Considering $\vDash$ the symbol for validity, the objective is finding \emph{$\phi$, P, $\psi$} that:
\[ \vDash \{\phi\} \, \textbf{P} \, \{\psi\} \ \ \ \rightarrow \ \ \ \ \ \vDash \{\Phi\} \, \textbf{P1} \sim \textbf{P2} \, \{\Psi\} \]

Let us consider two imperative and \emph{separable} programs \emph{P1} and \emph{P2}.
This enables the capacity of the assertions to be seen as first-order formulas about the variables of \emph{P1} and \emph{P2}.
Self-composition~\cite{DBLP:conf/csfw/BartheDR04} comes from the establishment of the wanted equalities above: \emph{P $\equiv$ P1;P2}, \emph{$\phi$ $\equiv$ $\Phi$} and \emph{$\psi$ $\equiv$ $\Psi$}.
This \hyperref[sec:self_composition]{already mentioned} construction is impractical~\cite{DBLP:conf/sas/TerauchiA05}, despite being sound and considerably complete.

There is another relevant method discussed in this \hyperref[sec:cross_products]{section}, the cross-products.
These suffer from the constraint of structural equivalence, making impossible to reason about properties or program optimizations that are based on different control flows.

Product Programs~\cite{DBLP:conf/fm/BartheCK11} appear to be the best path to follow, since they represent a general notion that combines the flexibility of self-composition in executing asynchronous steps and the efficiency of cross-products when it comes to treat synchronous steps. 


\subsection{From relational verification to standard verification} 
\label{sec:product_programs_relverif_to_stdverif}

(pag 5-8)


\subsection{Examples} 
\label{sec:product_programs_examples}

(pag 9-15)

