# 4 "lexer.mll"
 
  open Lexing
  (* open Ast *)
  open Parser

  exception Lexing_error of string

  type const =
    | Cint of int
    | Cbool of bool
    | Cstring of string

  type cmp = Beq | Bneq | Blt | Ble | Bgt | Bge

  let id_or_kwd =
    let h = Hashtbl.create 32 in
    List.iter (fun (s, tok) -> Hashtbl.add h s tok)
      [ "let", LET;
        "in", IN;
        "ref", REF;
        "if", IF;
        "then", THEN;
        "else", ELSE;
        "print", PRINT;
        "for", FOR;
        "while", WHILE;
        "do", DO;
        "done", DONE;
        "not", NOT;
        "true", CST (Cbool true);
        "false", CST (Cbool false);
        "int", INT;
        "bool", BOOL;];
   fun s -> try Hashtbl.find h s with Not_found -> IDENT s

  let string_buffer = Buffer.create 1024


# 41 "lexer.ml"
let __ocaml_lex_tables = {
  Lexing.lex_base =
   "\000\000\221\255\222\255\001\000\001\000\231\255\078\000\232\255\
    \233\255\002\000\235\255\236\255\237\255\238\255\003\000\078\000\
    \031\000\033\000\247\255\089\000\249\255\250\255\251\255\092\000\
    \192\000\004\000\003\000\255\255\253\255\011\001\224\255\248\255\
    \245\255\244\255\075\000\242\255\223\255\240\255\230\255\228\255\
    \225\255\227\255\143\000\252\255\253\255\096\000\109\000\255\255\
    \254\255\191\000\251\255\252\255\117\000\255\255\253\255\254\255\
    ";
  Lexing.lex_backtrk =
   "\255\255\255\255\255\255\029\000\034\000\255\255\023\000\255\255\
    \255\255\021\000\255\255\255\255\255\255\255\255\014\000\012\000\
    \026\000\009\000\255\255\034\000\255\255\255\255\255\255\034\000\
    \003\000\016\000\001\000\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\002\000\002\000\255\255\
    \255\255\255\255\255\255\255\255\003\000\255\255\255\255\255\255\
    ";
  Lexing.lex_default =
   "\001\000\000\000\000\000\255\255\255\255\000\000\255\255\000\000\
    \000\000\255\255\000\000\000\000\000\000\000\000\255\255\255\255\
    \255\255\255\255\000\000\255\255\000\000\000\000\000\000\255\255\
    \255\255\255\255\255\255\000\000\000\000\255\255\000\000\000\000\
    \000\000\000\000\255\255\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\044\000\000\000\000\000\255\255\255\255\000\000\
    \000\000\051\000\000\000\000\000\255\255\000\000\000\000\000\000\
    ";
  Lexing.lex_trans =
   "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\026\000\027\000\000\000\026\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \026\000\016\000\005\000\026\000\000\000\018\000\004\000\039\000\
    \025\000\013\000\020\000\022\000\010\000\021\000\028\000\019\000\
    \007\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \006\000\006\000\009\000\008\000\015\000\017\000\014\000\038\000\
    \037\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\012\000\033\000\011\000\032\000\023\000\
    \040\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\034\000\003\000\041\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \031\000\036\000\048\000\035\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\047\000\054\000\
    \000\000\000\000\000\000\000\000\000\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\045\000\
    \000\000\046\000\000\000\029\000\000\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\000\000\
    \030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\053\000\000\000\055\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \002\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\052\000\000\000\000\000\000\000\029\000\
    \000\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\000\000\000\000\
    \000\000\000\000\029\000\000\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\043\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\050\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000";
  Lexing.lex_check =
   "\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\000\000\000\000\255\255\026\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\000\000\000\000\026\000\255\255\000\000\000\000\004\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\025\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\009\000\
    \014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\016\000\000\000\017\000\000\000\
    \003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
    \000\000\000\000\000\000\015\000\000\000\003\000\006\000\006\000\
    \006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
    \019\000\034\000\045\000\015\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\046\000\052\000\
    \255\255\255\255\255\255\255\255\255\255\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\042\000\
    \255\255\042\000\255\255\023\000\255\255\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
    \023\000\023\000\023\000\023\000\023\000\023\000\023\000\255\255\
    \023\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\049\000\255\255\052\000\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\255\255\255\255\255\255\255\255\255\255\255\255\
    \000\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\049\000\255\255\255\255\255\255\024\000\
    \255\255\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\024\000\024\000\024\000\024\000\024\000\
    \024\000\024\000\024\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\
    \255\255\255\255\029\000\255\255\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\029\000\029\000\
    \029\000\029\000\029\000\029\000\029\000\029\000\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\042\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\049\000\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
    \255\255\255\255\255\255\255\255";
  Lexing.lex_base_code =
   "";
  Lexing.lex_backtrk_code =
   "";
  Lexing.lex_default_code =
   "";
  Lexing.lex_trans_code =
   "";
  Lexing.lex_check_code =
   "";
  Lexing.lex_code =
   "";
}

let rec next_tokens lexbuf =
   __ocaml_lex_next_tokens_rec lexbuf 0
and __ocaml_lex_next_tokens_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 50 "lexer.mll"
            ( new_line lexbuf; next_tokens lexbuf )
# 225 "lexer.ml"

  | 1 ->
# 51 "lexer.mll"
            ( next_tokens lexbuf )
# 230 "lexer.ml"

  | 2 ->
# 52 "lexer.mll"
            ( comment lexbuf; next_tokens lexbuf )
# 235 "lexer.ml"

  | 3 ->
let
# 53 "lexer.mll"
             id
# 241 "lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 53 "lexer.mll"
                ( id_or_kwd id )
# 245 "lexer.ml"

  | 4 ->
# 54 "lexer.mll"
            ( PLUS )
# 250 "lexer.ml"

  | 5 ->
# 55 "lexer.mll"
            ( MINUS )
# 255 "lexer.ml"

  | 6 ->
# 56 "lexer.mll"
            ( TIMES )
# 260 "lexer.ml"

  | 7 ->
# 57 "lexer.mll"
            ( DIV )
# 265 "lexer.ml"

  | 8 ->
# 58 "lexer.mll"
            ( MOD )
# 270 "lexer.ml"

  | 9 ->
# 59 "lexer.mll"
            ( EQUAL )
# 275 "lexer.ml"

  | 10 ->
# 60 "lexer.mll"
            ( CMP Beq )
# 280 "lexer.ml"

  | 11 ->
# 61 "lexer.mll"
            ( CMP Bneq )
# 285 "lexer.ml"

  | 12 ->
# 62 "lexer.mll"
            ( CMP Blt )
# 290 "lexer.ml"

  | 13 ->
# 63 "lexer.mll"
            ( CMP Ble )
# 295 "lexer.ml"

  | 14 ->
# 64 "lexer.mll"
            ( CMP Bgt )
# 300 "lexer.ml"

  | 15 ->
# 65 "lexer.mll"
            ( CMP Bge )
# 305 "lexer.ml"

  | 16 ->
# 66 "lexer.mll"
            ( LP )
# 310 "lexer.ml"

  | 17 ->
# 67 "lexer.mll"
            ( RP )
# 315 "lexer.ml"

  | 18 ->
# 68 "lexer.mll"
            ( LSQ )
# 320 "lexer.ml"

  | 19 ->
# 69 "lexer.mll"
            ( RSQ )
# 325 "lexer.ml"

  | 20 ->
# 70 "lexer.mll"
            ( COMMA )
# 330 "lexer.ml"

  | 21 ->
# 71 "lexer.mll"
            ( COLON )
# 335 "lexer.ml"

  | 22 ->
# 72 "lexer.mll"
            ( SEMICOLON )
# 340 "lexer.ml"

  | 23 ->
let
# 73 "lexer.mll"
               s
# 346 "lexer.ml"
= Lexing.sub_lexeme lexbuf lexbuf.Lexing.lex_start_pos lexbuf.Lexing.lex_curr_pos in
# 74 "lexer.mll"
            ( try CST (Cint (int_of_string s))
              with _ -> raise (Lexing_error ("Constant too large: " ^ s)) )
# 351 "lexer.ml"

  | 24 ->
# 76 "lexer.mll"
            ( CST (Cstring (string lexbuf)) )
# 356 "lexer.ml"

  | 25 ->
# 78 "lexer.mll"
            ( ASSIGN )
# 361 "lexer.ml"

  | 26 ->
# 79 "lexer.mll"
            ( DEREF )
# 366 "lexer.ml"

  | 27 ->
# 80 "lexer.mll"
            ( AND )
# 371 "lexer.ml"

  | 28 ->
# 81 "lexer.mll"
            ( OR )
# 376 "lexer.ml"

  | 29 ->
# 83 "lexer.mll"
            ( PIPE )
# 381 "lexer.ml"

  | 30 ->
# 84 "lexer.mll"
            ( LFLOOR )
# 386 "lexer.ml"

  | 31 ->
# 85 "lexer.mll"
            ( RFLOOR )
# 391 "lexer.ml"

  | 32 ->
# 86 "lexer.mll"
            ( SPEC_EQUAL )
# 396 "lexer.ml"

  | 33 ->
# 88 "lexer.mll"
            ( EOF )
# 401 "lexer.ml"

  | 34 ->
let
# 89 "lexer.mll"
         c
# 407 "lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 89 "lexer.mll"
            ( raise (Lexing_error ("Illegal character: " ^ String.make 1 c)) )
# 411 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_next_tokens_rec lexbuf __ocaml_lex_state

and comment lexbuf =
   __ocaml_lex_comment_rec lexbuf 42
and __ocaml_lex_comment_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 92 "lexer.mll"
          ( () )
# 423 "lexer.ml"

  | 1 ->
# 93 "lexer.mll"
          ( comment lexbuf; comment lexbuf )
# 428 "lexer.ml"

  | 2 ->
# 94 "lexer.mll"
          ( comment lexbuf )
# 433 "lexer.ml"

  | 3 ->
# 95 "lexer.mll"
          ( failwith "Comment not terminated" )
# 438 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_comment_rec lexbuf __ocaml_lex_state

and string lexbuf =
   __ocaml_lex_string_rec lexbuf 49
and __ocaml_lex_string_rec lexbuf __ocaml_lex_state =
  match Lexing.engine __ocaml_lex_tables __ocaml_lex_state lexbuf with
      | 0 ->
# 99 "lexer.mll"
      ( let s = Buffer.contents string_buffer in
	Buffer.reset string_buffer;
	s )
# 452 "lexer.ml"

  | 1 ->
# 103 "lexer.mll"
      ( Buffer.add_char string_buffer '\n';
	string lexbuf )
# 458 "lexer.ml"

  | 2 ->
# 106 "lexer.mll"
      ( Buffer.add_char string_buffer '"';
	string lexbuf )
# 464 "lexer.ml"

  | 3 ->
let
# 108 "lexer.mll"
         c
# 470 "lexer.ml"
= Lexing.sub_lexeme_char lexbuf lexbuf.Lexing.lex_start_pos in
# 109 "lexer.mll"
      ( Buffer.add_char string_buffer c;
	string lexbuf )
# 475 "lexer.ml"

  | 4 ->
# 112 "lexer.mll"
      ( raise (Lexing_error "String not terminated") )
# 480 "lexer.ml"

  | __ocaml_lex_state -> lexbuf.Lexing.refill_buff lexbuf;
      __ocaml_lex_string_rec lexbuf __ocaml_lex_state

;;

# 114 "lexer.mll"
 

  let next_token =
    let tokens = Queue.create () in (* next tokens to emit *)
    fun lb ->
      if Queue.is_empty tokens then begin
        let l = next_tokens lb in
        Queue.add l tokens
      end;
      Queue.pop tokens

  open Format

  let pp_token fmt (t: token) =
    match t with
    | WHILE -> fprintf fmt "while"
    | TIMES -> fprintf fmt "times"
    | THEN -> fprintf fmt "then"
    | SPEC_EQUAL -> fprintf fmt "<->"
    | RSQ -> fprintf fmt "]"
    | RP -> fprintf fmt ")"
    | RFLOOR -> fprintf fmt "_|"
    | REF -> fprintf fmt "ref"
    | PRINT -> fprintf fmt "print"
    | PLUS -> fprintf fmt "+"
    | PIPE -> fprintf fmt "|"
    | OR -> fprintf fmt "or"
    | NOT -> fprintf fmt "not"
    | NEWLINE -> fprintf fmt "newline"
    | MOD -> fprintf fmt "mod"
    | MINUS -> fprintf fmt "-"
    | LSQ -> fprintf fmt "["
    | LP -> fprintf fmt "("
    | LFLOOR -> fprintf fmt "|_"
    | LET -> fprintf fmt "let"
    | INT -> fprintf fmt "int"
    | IN -> fprintf fmt "in"
    | IF -> fprintf fmt "if"
    | IDENT s -> fprintf fmt "%s (identifier)" s
    | FOR -> fprintf fmt "for"
    | EQUAL -> fprintf fmt "="
    | EOF -> fprintf fmt "eof"
    | END -> fprintf fmt "end"
    | ELSE -> fprintf fmt "else"
    | DONE -> fprintf fmt "done"
    | DO -> fprintf fmt "do"
    | DIV -> fprintf fmt "/"
    | DEREF -> fprintf fmt "!"
    | CST c ->
      let s =
        match c with
        | Cint  i -> string_of_int i
        | Cbool b -> string_of_bool b
        | Cstring str -> str
        | Cnone -> "Cnone"
      in
      fprintf fmt "%s (const)" s

    | COMMA -> fprintf fmt ","
    | COLON -> fprintf fmt ":"
    | SEMICOLON -> fprintf fmt ";"
    | CMP op ->
      let s =
        match op with
        | Beq  -> "=="
        | Bneq -> "!="
        | Blt  -> "<"
        | Ble  -> "<="
        | Bgt  -> ">"
        | Bge  -> ">="
      in
      fprintf fmt "%s (cmp)" s

    | BOOL -> fprintf fmt "bool"
    | BEGIN -> fprintf fmt "begin"
    | ASSIGN -> fprintf fmt ":="
    | AND -> fprintf fmt "and"

  let () =
    let fname = Sys.argv.(1) in
    let cin = open_in fname in
    let lb = Lexing.from_channel cin in
    let rec loop () =
      let token : Parser.token = next_token lb in
      eprintf "@[%a@]@." pp_token token;
      if token <> EOF then loop () in
    loop ()


# 577 "lexer.ml"
