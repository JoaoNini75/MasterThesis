let empty_args_test () = begin
	8 * 7
end
(*@ ensures true *)

let empty_args_apply_test (x) = begin
	empty_args_test ()
end
(*@ ensures true *)


let app_fun (x : int) = begin
	x
end
(*@ ensures true *)

let app_mid_test (x : int, b : bool) = begin
	app_fun (x);
	2 + 2
end
(*@ ensures true *)

let app_let_test (x : int, b : bool) = begin
	let app_res = app_fun (1) in
	app_res
end
(*@ ensures true *)

let app_end_test (x : int, b : bool) = begin
	app_fun (1)
end
(*@ ensures true *) 


let assert_test (x) = begin
	assert (1 <> 3)
end
(*@ ensures true *)


let funs_nested (x) = begin
  let fun_inner (i) = begin
		let i = ref 0 in
		while !i < 3 do
			i := !i + 2;
			i := !i - 1
		done;
		!i
  end
	(*@ ensures true *)
	in

  fun_inner (x)
end
(*@ ensures true *) 


let match_test (x : int, y : int) : string = begin
  match x with 
	| 0 -> "zero"
	| y -> "y"
	| _ -> "other"
end
(*@ ensures true *) 

let match_test2 (|_ x : int _|) : |_ int _| = begin
	let a = 1 <|> 1 in

	let b = |_ (
		match x with
		| 0 -> 10
		| 1 -> 11
		| _ -> -1 
	) _| in

	a + b <|> a + b
end
(*@ ensures true *)



let assignment_only (|_x1 : int_|, |_y1 : int_|) : |_int_| = begin
	let x2 = y1 * 2 <|> y2 = y1 * 2 + 1 in
	let y2 = x2 + 1 <|> x2 = y2 - 1 in
	|_ x2 + y2 _|
end
(*@ requires x1_l = x1_r && y1_l = y1_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *)

let bilateral_conditional (|_c : bool _|) : |_int_| = begin
	if |_c_| 
	then begin |_1_| end
	else begin |_0_| end
end
(*@ requires c_l <-> c_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *)

let induc_var_strength_red (|_b : int_|, |_c : int_|, |_n : int_|) : |_int_| = begin
	let i = |_ ref 0 _| in
	let j = ref 0 <|> ref c in
	let x = |_ ref 0 _| in

	while |_ !i < n _| do
		(*@ invariant !i_l >= 0 && !i_r >= 0 && !i_l = !i_r && (n_l >= 0 -> !i_l <= n_l)
        invariant !j_r = !i_r * b_r + c_r
        invariant !x_l = !x_r 
        variant n_l - !i_l *)
		j := !i * b + c <|> x := !x + !j;
		x := !x + !j    <|> j := !j + b;
		i := |_ !i + 1 _|
	done;

	|_ !x _|
end
(*@ requires b_l = b_r && c_l = c_r && n_l = n_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *) 



(*@ axiom mult: forall a:int, b:int, c:int, d:int.
   0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b -> c > d -> (a * c) > (b * d) *) 
   
let cond_align_loops (|_x : int_|, |_n : int_|) : |_int_| = begin
	let y = |_ ref x _| in
	let z = ref 24 <|> ref 16 in 
	let w = |_ ref 0 _| in

	while !y > 4 <|> !y > 4 . (!w mod 2 <> 0) <|> (!w mod 2 <> 0) do
		(*@ variant   !y_l + !y_r
				invariant !z_l > !z_r && !y_l = !y_r && !y_r >= 4 && !z_l > 0 && !z_r > 0 *)

		if ((!w mod n == 0) <|> (!w mod n == 0)) then begin
			z := (!z * !y <|> !z * 2);
			y := |_ !y - 1 _|
		end else begin () end;

		w := |_ !w + 1 _|
	done; 

	|_ !z _|
end
(*@ requires x_l = x_r && n_l = n_r && n_r > 0 && x_l >= 4
    ensures  match result with (l_res, r_res) -> l_res > r_res *) 

let cond_align_loops_nested (|_x : int_|, |_n : int_|) : |_int_| = begin
	let y = |_ ref x _| in
	let z = ref 24 <|> ref 16 in 
	let w = |_ ref 0 _| in
	let t = ref 0 <|> ref 1 in

	while !y > 4 <|> !y > 4 . (!w mod 2 <> 0) <|> (!w mod 2 <> 0) do
		(*@ variant   !y_l + !y_r
				invariant !z_l > !z_r && !y_l = !y_r && !y_r >= 4 && !z_l > 0 && !z_r > 0 *)

		while !t < 4 <|> !t < 4 . (!t mod 2 <> 0) <|> (!t mod 2 <> 0) do
			(*@ variant   !t_l + !t_r 
					invariant !t_l >= 0 && !t_r >= 1 *)
			t := |_ !t + 1 _|
		done;

		y := |_ !y - 1 _|;
		w := |_ !w + 1 _|
	done; 

	|_ !z _|
end
(*@ requires x_l = x_r && n_l = n_r && n_r > 0 && x_l >= 4
    ensures  match result with (l_res, r_res) -> l_res > r_res *) 



let rec bip_short (b : int <|> b : int) : int <|> int = begin
    let x = ref 0 <|> ref 1 in
    !x <|> !x 
end
(*@ ensures true *)

let bip (|_b : int_|) : |_int_| = begin
    (* comment1 *)
    let i = ref 0 in
    let j = ref 0 <|> ref b in
    let x = |_ ref 0 _| in
    |_ !x _|
end
(*@ ensures true *)

let bip_if_long (|_ x1 : int _|, |_ y1 : bool _|) : |_ int _| = begin
    let x2 = |_ x1 * 2 _| in
    let y2 = |_ 34 _| in
    if |_ y2 > x2 _| then begin
      |_ x2 + y2 _|
    end else begin
      |_ x2 - y2 _|
    end
end
(*@ ensures true *)

let semicolon_assign () = begin
    let a = ref 0 in
    a := 5;
    a := !a + 1;
    !a
end
(*@ ensures true *)

let bip2 (x, y) = begin
    let z = |_ ref -1 _| in
    let b = not (true && false) in
    z := |_ !z + 1 _|;
    b
end
(*@ ensures true *)

let bip3 (x : int, y) = begin
    let z = ref x in
    for i = 0 to y do
        z := !z * 3
    done;
    !z
end
(*@ ensures true *)

let fact_iter (n) = begin
	if n <= 1 
    then begin 1 end
	else
		begin 
			let res = ref 1 in
			for i = 2 to n do
				
				res := !res * i
			done;
            !res
		end
end
(*@ ensures true *)

let bip_if2 (|_c : bool _|) : |_int_| = begin
    if |_c_| 
    then begin |_1_| end
    else begin |_0_| end
end
(*@ ensures true *)

let semicolon_test () = begin
    let x = ref 0 in
    x := 1;
    x := 2;
    x
end
(*@ ensures true *)

let gcd_iter (a0, b0) = begin 
    let b = ref b0 in
    let a = ref a0 in
    while !b <> 0 do
        let tmp = !a in
        a := !b;
        b := tmp mod !b
    done;
    !a
end
(*@ ensures true *)

let p2 () = begin
    let x = |_ ref 1 _| in
    let y = |_ ref 2 _| in
    x := !x + 1 <|> y := !y + 2;
    let z = ref 22 in
    !z
end
(*@ ensures true *)

let app2 (arg1 : int, arg2 : int) : int = begin
	arg1 * arg2
end
(*@ ensures true *)

let app () = begin
	let a = ref 4 in
	let res = fact_iter (!a * 5) in
	app2 (1 * !a, 2 * !a)
end
(*@ ensures true *)


type number = 
	| Neg of int 
	| Pos of int * bool * int
	| Zero

type simple = number * bool

and complex =
	| Num1 of simple * int
	| Num2 of simple * bool

and third = complex * simple

let test_construction (num) : simple = begin
	let x = Pos (num, true, 3) in
	let y = (x, true || false) in
	y
end
(*@ ensures true *)

let match_destruct () : int = begin
	let x = Zero in
	match x with
	| Zero -> 0
	| Neg n -> n
	| Pos (n, b, third) -> 
		if b 
		then begin third end 
		else begin n+1 end
end
(*@ ensures true *)


type number2 = 
  | Pos2 of int * int 
  | Neg2 
  | Zero2

let match_assert (x : int) = begin
  let y = 
    if x > 0 then begin Pos2 (2, 4) end
    else begin Zero2 end
  in  

		let res = 
			( match y with
			| Pos2 (i, n) -> 10
			| Neg2 -> -10
			| Zero2 -> 0 ) 
		in
		
		assert ((res >= -10));
		res
end
(*@ ensures x > 0 -> result = 10
    ensures x = 0 -> result = 0
    ensures x < 0 -> result = -10 *)

let test () = begin
	Neg2
end
(*@ ensures true *)

open A 

include B 

let arrays (a) = begin
	let a = [| 1; 2; 3 |] in
	let b = [| |] in
	let c = [| 7 |] in
	assert (Array.length (b) + 1 == Array.length (c));
	let last_elem_idx = Array.length (a) - 1 in
	assert (a.(last_elem_idx) == 3);
	a.(last_elem_idx) <- 42;
  assert (a.(last_elem_idx) == 42);
	(Array.get (a, last_elem_idx)) == a.(last_elem_idx)
end
(*@ ensures true *)

let module_apps (a) = begin
	let arr_len = ref (Array.length (a)) in
	Printf.printf ("%d", !arr_len);
	Printf.printf ("\nlast print")
end
(*@ ensures true *)

