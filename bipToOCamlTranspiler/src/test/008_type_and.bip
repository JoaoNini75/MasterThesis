type number = 
	| Neg of int 
	| Pos of int * bool * int
	| Zero

type simple = number * bool

and complex =
	| Num1 of simple * int
	| Num2 of simple * bool

and third = complex * simple

let test_construction (num) : simple = begin
	let x = Pos (num, true, 3) in
	let y = (x, true || false) in
	y
end
(*@ ensures true *)

let match_destruct () : int = begin
	let x = Zero in
	match x with
	| Zero -> 0
	| Neg n -> n
	| Pos (n, b, third) -> 
		if b 
		then begin third end 
		else begin n+1 end
end
(*@ ensures true *)


type number2 = 
  | Pos2 of int * int 
  | Neg2 
  | Zero2

let match_assert (x : int) = begin
  let y = 
    if x > 0 then begin Pos2 (2, 4) end
    else begin Zero2 end
  in  

  let res = (
    match y with
    | Pos2 (i, n) -> 10
    | Neg2 -> -10
    | Zero2 -> 0 
  ) in
  
  assert ((res >= -10));
  res
end
(*@ ensures x > 0 -> result = 10
    ensures x = 0 -> result = 0
    ensures x < 0 -> result = -10 *)

let test () = begin
	Neg2
end
(*@ ensures true *)
