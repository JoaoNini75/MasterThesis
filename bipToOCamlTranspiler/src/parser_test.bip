let assignment_only (|_x1 : int_|, |_y1 : int_|) : |_int_| = begin
	let x2 = y1 * 2 | y2 = y1 * 2 + 1 in
	let y2 = x2 + 1 | x2 = y2 - 1 in
	|_ x2 + y2 _|
end
(*@ requires x1_l = x1_r && y1_l = y1_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *)

let bilateral_conditional (|_c : bool _|) : |_int_| = begin
	if |_c_| 
	then begin |_1_| end
	else begin |_0_| end
end
(*@ requires c_l <-> c_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *)
(* requires c =:= c *)

let induc_var_strength_red (|_b : int_|, |_c : int_|, |_n : int_|) : |_int_| = begin
	let i = |_ ref 0 _| in
	let j = ref 0 | ref c in
	let x = |_ ref 0 _| in

	while |_ !i < n _| do
		(*@ invariant !i_l >= 0 && !i_r >= 0 && !i_l = !i_r && (n_l >= 0 -> !i_l <= n_l)
            invariant !j_r = !i_r * b_r + c_r
            invariant !x_l = !x_r 
            variant n_l - !i_l *)
		j := !i * b + c | x := !x + !j;
		x := !x + !j    | j := !j + b;
		i := |_ !i + 1 _|
	done;

	|_ !x _|
end
(*@ requires b_l = b_r && c_l = c_r && n_l = n_r
    ensures  match result with (l_res, r_res) -> l_res = r_res *) 

(*@ axiom mult: forall a:int, b:int, c:int, d:int.
   0 < a -> 0 < b -> 0 < c -> 0 < d -> a > b -> c > d -> (a * c) > (b * d) *)
   
let cond_align_loops (|_x : int_|, |_n : int_|) : |_int_| = begin
	let y = |_ ref x _| in
	let z = ref 24 | ref 16 in 
	let w = |_ ref 0 _| in

	while !y > 4 | !y > 4 . (!w mod n <> 0) | (!w mod n <> 0) do
        (*@ variant   !y_l + !y_r
            invariant !z_l > !z_r && !y_l = !y_r && !y_r >= 4 && !z_l > 0 && !z_r > 0 *)

		if ((!w mod n == 0) | (!w mod n == 0)) then begin
			z := (!z * !y | !z * 2);
			y := |_ !y - 1 _|
		end else begin () end;

		w := |_ !w + 1 _|
	done; 

	|_ !z _|
end
(*@ requires x_l = x_r && n_l = n_r && n_r > 0 && x_l >= 4
    ensures  match result with (l_res, r_res) -> l_res > r_res *) 


(*let bip_short (b : int | b : int) : int | int = begin
    let x = ref 0 | ref 1 in
    !x | !x 
end

let bip (|_b : int_|) : |_int_| = begin
    (* comment1 *)
    let i = ref 0 in
    let j = ref 0 | ref b in
    let x = |_ ref 0 _| in
    |_ !x _|
end



let bip_if_long (|_ x1 : int _|, |_ y1 : bool _|) : |_ int _| = begin
    let x2 = |_ x1 * 2 _| in
    let y2 = |_ 34 _| in
    if |_ y2 > x2 _| then begin
      |_ x2 + y2 _|
    end else begin
      |_ x2 - y2 _|
    end
end


let semicolon_assign () = begin
    let a = ref 0 in
    a := 5;
    a := !a + 1;
    !a
end

let bip2 (x, y) = begin
    let z = |_ ref -1 _| in
    let b = not (true && false) in
    z := |_ !z + 1 _|;
    b
end

let bip3 (x : int, y) = begin
    let z = ref x in
    for i = 0 to y do
        z := !z * 3
    done;
    !z
end

let fact_iter (n) = begin
	if n <= 1 
    then begin 1 end
	else
		begin 
			let res = ref 1 in
			for i = 2 to n do
				
				res := !res * i
			done;
            !res
		end
end

let bip_if2 (|_c : bool _|) : |_int_| = begin
    if |_c_| 
    then begin |_1_| end
    else begin |_0_| end
end


let semicolon_test () = begin
    let x = ref 0 in
    x := 1;
    x := 2;
    x
end

let gcd_iter (a0, b0) = begin 
    let b = ref b0 in
    let a = ref a0 in
    while !b <> 0 do
        let tmp = !a in
        a := !b;
        b := tmp mod !b
    done;
    !a
end

let p2 () = begin
    let x = |_ ref 1 _| in
    let y = |_ ref 2 _| in
    x := !x + 1 | y := !y + 2;
    let z = ref 22 in
    !z
end

let app2 (arg1 : int, arg2 : int) : int = begin
    arg1 * arg2
end

let app () = begin
    let a = ref 4 in
    let res = fact_iter (!a * 5) in
    app2 (1 * !a, 2 * !a)
end*)
