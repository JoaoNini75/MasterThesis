let bip_short (|_b : int_|) : |_int_| = begin
    let i = ref 0 in
    let j = ref 0 in | let j = ref c in;
    |_ let x = ref 0 in _|;
    |_ !x _|
end

let bip_short_pipe (b : int | b : int) : int | int = begin
    let i = ref 0 in
    let j = ref 0 in | let j = ref c in;
    let x = ref 0 in | ;
    !x | !x 
end

let bip_short_tp (b_l : int, b_r : int) : (int, int) = begin
    let i = ref 0 in
    let j_l = ref 0 in
    let j_r = ref c in
    let x_l = ref 0 in
    let x_r = ref 0 in
    (!x_l, !x_r) 
end

let x = 42 and y = 73 in

let i_l = ref 0 in 
let i_r = ref 0 in 
let j_l = ref 0 in 
let j_r = ref c in 


let bip_complete (|_b : int_|, |_c : int_|, |_n : int_|) : |_int_| = begin
    let i = |_ ref 0 _| in
    let j = (ref 0 | ref c) in
    let x = |_ ref 0 _| in

    |_ while (|_ !i < n _|) do
        j := !i * b + c | x := !x + !j;
        x := !x + !j    | j := !j + b;
        |_ i := !i + 1 _|
    done _|

    |_ !x _|
end

let bip (|_ x1 : int _|, |_ y1 : bool _|) : |_ int _| = begin
    let x2 = |_ y1 * 2 _| in
    let y2 = |_ 34 _| in
    if |_ y2 > x2 _|
    then begin |_ x2 + y2 _| end
    else begin |_ x2 - y2 _| end
end
(*@ requires x1 <-> x1 && y1 <-> y1*)

let bip2 (x, y) = begin
    let z = ref (-1) in
    let b = not (true && false) in
    z := |_ !z + 1 _|;
    b
end

let bip3 (x : int, y) = begin
    let z = ref x in
    for i = 0 to y do
        z := !z * 3
    done;
    !z
end

let fact_iter (n) = begin
	if n <= 1 
    then begin 1 end
	else
		begin 
			let res = ref 1 in
			for i = 2 to n do
				(*@ invariant !res = fact (i-1) *)
				res := !res * i
			done
		end
end

let bip_if (|_c_|) : |_int_| = begin
    if |_c_| 
    then begin |_1_| end
    else begin |_0_| end
end
(*@ requires c <-> c *)

let semicolon_test () = begin
    let x = ref 0 in
    x := 1;
    x := 2;
    x
end

let gcd_iter (a0, b0) = begin 
    let b = ref b0 in
    let a = ref a0 in
    while !b <> 0 do
        (*@ invariant 0 <= !b
            invariant 0 <= !a
            invariant gcd a0 b0 = gcd !a !b
            variant !b *)
        let tmp = !a in
        a := !b;
        b := tmp mod !b
    done;
    !a
end

let p2 () = begin
    let x = ref 1 in
    let y = ref 2 in
    x := !x + 1 | y := !y + 2;
    !x
end
